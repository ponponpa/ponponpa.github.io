<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常识总结</title>
      <link href="/2021/10/04/%E5%B8%B8%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/04/%E5%B8%B8%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><h4 id="1-js"><a href="#1-js" class="headerlink" title="1. js"></a>1. js</h4><p>面向对象、面向过程。<br>对象的创建－字面量，原型，构造函数等各自特点<br>（你开发过什么什么插件）</p><p>继承 － 原型，原型连，es6继承 ，call，apply<br>闭包－是什么，什么情况会出现，项目中用它处理什么<br>es6相对于es5新增技术，你常用哪些？<br>promise怎么用的？用它做过什么功能？<br>ajax交互的底层原理，如何封装ajax；ajax，axios，fetch区别对比<br>深拷贝，浅拷贝<br>常用数组方法，数组－字符串转换</p><h4 id="2-vue"><a href="#2-vue" class="headerlink" title="2. vue"></a>2. vue</h4><p>vue数据双向绑定底层原理。<br>项目中你用到了那些vue技术（vue指令、自定义指令，过滤器、组件、动画、axios、路由、vuex，生命周期函数）－具体实现了什么功能<br>axios的底层原理是什么？ vue项目中用axios出现跨域问题怎么处理的？跟ajax的区别是什么？<br>vue中做什么功能用到了组件件传旨？传旨方式有哪些？怎么实现的？<br>vue路由  路由传参数有哪些方法？项目中传递什么数据用哪种传参？<br>嵌套路由怎么动态接受参数？用什么方法？（watch）<br>编程式路由怎么做？怎么传餐？<br>路由用什么模式？hash跟history区别，怎么转换？<br>路由拦截在项目中做什么功能的时候用到了？怎么用的？<br>命名路由的好处是什么？<br>vuex怎么用的项目中（state，actions，mutations，getters，module）分别在项目中负责做什么？<br>vue性能优化，路由懒加载实现</p><h4 id="3-react"><a href="#3-react" class="headerlink" title="3. react"></a>3. react</h4><p>react数据绑定底层原理？<br>项目中你用到了那些react技术（组件、组件传旨，动画、路由、生命周期、redux／flux／react-redux）－具体实现了什么功能<br>组件划分，受控，非受控，有状态无状态等<br>react生命周期函数在项目中做什么功能？<br>diff算法的好处<br>组件传旨怎么做？<br>react路由嵌套路由传参怎么做？怎么动态接受？<br>路由用什么模式？hash跟history区别，怎么转换？<br>状态管理器怎么用的？<br>redux（view，action，store，reducer）分别干什么的？<br>reducer拆分怎么做？<br>用过redux哪些异步插件？（thunk，saga，promise）</p><h4 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4. webpack"></a>4. webpack</h4><p>webpack用过哪些插件，加载器？项目中用来做什么的？<br>会不会自己配置webpack？具体包含哪些信息？</p><h4 id="5-other"><a href="#5-other" class="headerlink" title="5. other"></a>5. other</h4><p>项目中具体怎么用sass的？对比css好处在哪里。<br>mock怎么用的？怎么模拟post请求？<br>项目中的组件怎么测试的？（mocha）<br>项目开发中遇到过哪些问题？怎么处理的？<br>小程序开发中遇到的问题？</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则</title>
      <link href="/2021/02/01/%E6%AD%A3%E5%88%99/"/>
      <url>/2021/02/01/%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式到底是什么"><a href="#正则表达式到底是什么" class="headerlink" title="正则表达式到底是什么"></a>正则表达式到底是什么</h3><p>正则表达式(Regular Expression)其实就是一门工具，目的是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种用来描述规则的表达式。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用regexper.com这个工具很好地可视化自己写的正则表达式</p><p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\\d&#123;1,4&#125;)(-|\\/</span>)(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)\\<span class="number">2</span>(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)$/; </span><br><span class="line"><span class="keyword">var</span> r = fieldValue.match(reg);             </span><br><span class="line"><span class="keyword">if</span>(r==<span class="literal">null</span>)alert(<span class="string">'Date format error!'</span>);</span><br></pre></td></tr></table></figure><p>下面整理一下，在前端开发中经常使用到的正则表达式。</p><h4 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1. 校验密码强度"></a>1. 校验密码强度</h4><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure><h4 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a>2. 校验中文</h4><p>字符串仅能是中文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\\u4e00-\\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br></pre></td></tr></table></figure><h4 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a>3. 由数字、26个英文字母或下划线组成的字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\\w+$</span><br></pre></td></tr></table></figure><h4 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a>4. 校验E-Mail 地址</h4><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br></pre></td></tr></table></figure><h4 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a>5. 校验身份证号码</h4><p>下面是身份证号码的正则校验。15 或 18位。<br>15位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;$</span><br></pre></td></tr></table></figure><p>18位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;([<span class="number">0</span><span class="number">-9</span>]|X)$</span><br></pre></td></tr></table></figure><h4 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a>6. 校验日期</h4><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!<span class="number">0000</span>)[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>&#125;-(?:(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-8</span>])|(?:<span class="number">0</span>[<span class="number">13</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">29</span>|<span class="number">30</span>)|(?:<span class="number">0</span>[<span class="number">13578</span>]|<span class="number">1</span>[<span class="number">02</span>])<span class="number">-31</span>)|(?:[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])|(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])<span class="number">00</span>)<span class="number">-02</span><span class="number">-29</span>)$</span><br></pre></td></tr></table></figure><h4 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a>7. 校验金额</h4><p>金额校验，精确到2位小数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br></pre></td></tr></table></figure><h4 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a>8. 校验手机号</h4><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\\d&#123;<span class="number">8</span>&#125;$</span><br></pre></td></tr></table></figure><h4 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a>9. 判断IE的版本</h4><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.*MSIE [<span class="number">5</span><span class="number">-8</span>](?:\\.[<span class="number">0</span><span class="number">-9</span>]+)?(?!.*Trident\\/[<span class="number">5</span><span class="number">-9</span>]\\<span class="number">.0</span>).*$</span><br></pre></td></tr></table></figure><h4 id="10-提取URL链接"><a href="#10-提取URL链接" class="headerlink" title="10. 提取URL链接"></a>10. 提取URL链接</h4><p>下面的这个表达式可以筛选出一段文本中的URL。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(f|ht)&#123;<span class="number">1</span>&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出webpack</title>
      <link href="/2020/07/16/webpack/"/>
      <url>/2020/07/16/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p> webpack核心概念：</p><ul><li>Entry：入口，Webpack执行构建的第一步将从Entry开始，可抽象成输入。</li><li>Moudule：模块，在Webpack里面一切皆模块，一个模块对应一个文件。webpack会从配置的Entry开始递归找出所有依赖的模块。</li><li>Chunk：代码块，一个Chunk由多个模块组合而成，用于代码合并和分割。</li><li>Loader：模块转换器，用于将模块的原内容按照需求转换成新内容。</li><li>Plugin：扩展插件，在Webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果或做我们想要做的事。</li><li>Output：输出结果，在Webpack经过一系列处理并得到出最终想要的代码后输出结果。</li></ul><p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。</p><p>在实际应用中你可能会遇到各种奇怪复杂的场景，不知道从哪开始。 根据以上总结，你会对 Webpack 有一个整体的认识，这能让你在以后使用 Webpack 的过程中快速知道应该通过配置什么去完成你想要的功能，而不是无从下手。</p><hr><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>若想让源文件加入构建流程中被Webpack控制，则配置entry;</li><li>若想自定义输出文件的位置和名称，则配置output;</li><li>若想自定义寻找依赖模块时的策略，则配置resolve;</li><li>若想自定义解析和转换文件的策略，则配置module，通常是配置module.rules里的Loader;</li><li>若其他大部分需求可能通过Plugin去实现，则配置plugin。</li></ul><p>再从大模块下去查仔细的文档即可</p><hr><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><ul><li>使用新语言来开发项目使用ES6语言；使用TypeScript语言；使用Flow检查器；使用SCSS语言；使用PostCSS</li><li>使用新框架来开发项目；使用React框架；使用Vue框架</li><li>用Webpack构建单页应用</li><li>用Webpack构建不同运行环境下的项目</li><li>Webpack结合其他工具搭配使用，各取所长[动画表情]搭配NpmScript;代码检查</li><li>用Webpack加载特殊类型的资源；加载图片；加载SVG；加载Sourse Map</li></ul><hr><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>缩小文件搜索范围</li><li>使用DIIPlugin</li><li>使用HappyPack</li><li>使用ParallelUglifyPlugin</li><li>使用自动刷新</li><li>开启模块热替换</li><li>区分环境</li><li>压缩代码</li><li>CDN加速</li><li>使用Tree Shaking</li><li>提取公共代码</li><li>按需加载</li><li>使用Prepack</li><li>开启 Scopra Hoisting</li><li>输出分析</li></ol><hr><p>侧重优化开发体验的配置文件 webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">AutoWebPlugin</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'web-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123;</span></span><br><span class="line"><span class="comment">// HTML 模版文件所在的文件路径</span></span><br><span class="line">template: <span class="string">'./template.html'</span>,</span><br><span class="line"><span class="comment">// 提取出所有页面公共的代码</span></span><br><span class="line">commonsChunk: &#123;</span><br><span class="line"><span class="comment">// 提取出公共代码 Chunk 的名称</span></span><br><span class="line">name: <span class="string">'common'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</span></span><br><span class="line"><span class="comment">// autoWebPlugin.entry 方法可以获取到生成入口配置</span></span><br><span class="line">entry: autoWebPlugin.entry(&#123;</span><br><span class="line"><span class="comment">// 这里可以加入你额外需要的 Chunk 入口</span></span><br><span class="line">base: <span class="string">'./src/base.js'</span>,</span><br><span class="line">&#125;),</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'[name].js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line"><span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line"><span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line"><span class="comment">// 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件，使用 Tree Shaking 优化</span></span><br><span class="line"><span class="comment">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">mainFields: [<span class="string">'jsnext:main'</span>, <span class="string">'main'</span>],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [&#123;</span><br><span class="line"><span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line"><span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line">use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line"><span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">use: [<span class="string">'happypack/loader?id=ui-component'</span>],</span><br><span class="line">include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">use: [<span class="string">'happypack/loader?id=css'</span>],</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">autoWebPlugin,</span><br><span class="line"><span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">id: <span class="string">'babel'</span>,</span><br><span class="line"><span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line"><span class="comment">// UI 组件加载拆分</span></span><br><span class="line">id: <span class="string">'ui-component'</span>,</span><br><span class="line">loaders: [&#123;</span><br><span class="line">loader: <span class="string">'ui-component-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">lib: <span class="string">'antd'</span>,</span><br><span class="line">style: <span class="string">'style/index.css'</span>,</span><br><span class="line">camel2: <span class="string">'-'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">id: <span class="string">'css'</span>,</span><br><span class="line"><span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line">loaders: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 4-11提取公共代码</span></span><br><span class="line"><span class="keyword">new</span> CommonsChunkPlugin(&#123;</span><br><span class="line"><span class="comment">// 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span></span><br><span class="line">chunks: [<span class="string">'common'</span>, <span class="string">'base'</span>],</span><br><span class="line"><span class="comment">// 把公共的部分放到 base 中</span></span><br><span class="line">name: <span class="string">'base'</span></span><br><span class="line">&#125;),</span><br><span class="line">],</span><br><span class="line">watchOptions: &#123;</span><br><span class="line"><span class="comment">// 4-5使用自动刷新：不监听的 node_modules 目录下的文件</span></span><br><span class="line">ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>侧重优化输出质量的配置文件 webpack-dist.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DefinePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DefinePlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ModuleConcatenationPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/ModuleConcatenationPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">AutoWebPlugin</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'web-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123;</span></span><br><span class="line"><span class="comment">// HTML 模版文件所在的文件路径</span></span><br><span class="line">template: <span class="string">'./template.html'</span>,</span><br><span class="line"><span class="comment">// 提取出所有页面公共的代码</span></span><br><span class="line">commonsChunk: &#123;</span><br><span class="line"><span class="comment">// 提取出公共代码 Chunk 的名称</span></span><br><span class="line">name: <span class="string">'common'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 指定存放 CSS 文件的 CDN 目录 URL</span></span><br><span class="line">stylePublicPath: <span class="string">'//css.cdn.com/id/'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</span></span><br><span class="line"><span class="comment">// autoWebPlugin.entry 方法可以获取到生成入口配置</span></span><br><span class="line">entry: autoWebPlugin.entry(&#123;</span><br><span class="line"><span class="comment">// 这里可以加入你额外需要的 Chunk 入口</span></span><br><span class="line">base: <span class="string">'./src/base.js'</span>,</span><br><span class="line">&#125;),</span><br><span class="line">output: &#123;</span><br><span class="line"><span class="comment">// 给输出的文件名称加上 Hash 值</span></span><br><span class="line">filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line"><span class="comment">// 指定存放 JavaScript 文件的 CDN 目录 URL</span></span><br><span class="line">publicPath: <span class="string">'//js.cdn.com/id/'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line"><span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line"><span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line"><span class="comment">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">mainFields: [<span class="string">'jsnext:main'</span>, <span class="string">'main'</span>],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [&#123;</span><br><span class="line"><span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line"><span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line">use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line"><span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">use: [<span class="string">'happypack/loader?id=ui-component'</span>],</span><br><span class="line">include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span></span><br><span class="line">use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">use: [<span class="string">'happypack/loader?id=css'</span>],</span><br><span class="line"><span class="comment">// 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL</span></span><br><span class="line">publicPath: <span class="string">'//img.cdn.com/id/'</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">autoWebPlugin,</span><br><span class="line"><span class="comment">// 4-14开启ScopeHoisting</span></span><br><span class="line"><span class="keyword">new</span> ModuleConcatenationPlugin(),</span><br><span class="line"><span class="comment">// 4-3使用HappyPack</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line"><span class="comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span></span><br><span class="line">id: <span class="string">'babel'</span>,</span><br><span class="line"><span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line"><span class="comment">// UI 组件加载拆分</span></span><br><span class="line">id: <span class="string">'ui-component'</span>,</span><br><span class="line">loaders: [&#123;</span><br><span class="line">loader: <span class="string">'ui-component-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">lib: <span class="string">'antd'</span>,</span><br><span class="line">style: <span class="string">'style/index.css'</span>,</span><br><span class="line">camel2: <span class="string">'-'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">id: <span class="string">'css'</span>,</span><br><span class="line"><span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line"><span class="comment">// 通过 minimize 选项压缩 CSS 代码</span></span><br><span class="line">loaders: [<span class="string">'css-loader?minimize'</span>],</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line"><span class="comment">// 给输出的 CSS 文件名称加上 Hash 值</span></span><br><span class="line">filename: <span class="string">`[name]_[contenthash:8].css`</span>,</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 4-11提取公共代码</span></span><br><span class="line"><span class="keyword">new</span> CommonsChunkPlugin(&#123;</span><br><span class="line"><span class="comment">// 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span></span><br><span class="line">chunks: [<span class="string">'common'</span>, <span class="string">'base'</span>],</span><br><span class="line"><span class="comment">// 把公共的部分放到 base 中</span></span><br><span class="line">name: <span class="string">'base'</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line"><span class="comment">// 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分</span></span><br><span class="line"><span class="string">'process.env'</span>: &#123;</span><br><span class="line">NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span></span><br><span class="line"><span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line"><span class="comment">// 传递给 UglifyJS 的参数</span></span><br><span class="line">uglifyJS: &#123;</span><br><span class="line">output: &#123;</span><br><span class="line"><span class="comment">// 最紧凑的输出</span></span><br><span class="line">beautify: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 删除所有的注释</span></span><br><span class="line">comments: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">compress: &#123;</span><br><span class="line"><span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">warnings: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">drop_console: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">collapse_vars: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">reduce_vars: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;),</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行</title>
      <link href="/2019/12/11/%E6%97%85%E8%A1%8C/"/>
      <url>/2019/12/11/%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="梦开始得地方"><a href="#梦开始得地方" class="headerlink" title="梦开始得地方"></a>梦开始得地方</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从敲入 URL 到浏览器渲染完成</title>
      <link href="/2019/11/13/%E4%BB%8E%E6%95%B2%E5%85%A5%20URL%20%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90/"/>
      <url>/2019/11/13/%E4%BB%8E%E6%95%B2%E5%85%A5%20URL%20%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="大致过程："><a href="#大致过程：" class="headerlink" title="大致过程："></a>大致过程：</h2><ul><li>当用户输入url地址，浏览器查询DNS查找对应的请求IP地址</li><li>建立TCP连接</li><li>浏览器向服务器发送http请求，如果服务器返回以301之类的重定向，浏览器根据相应头中的location再次发送请求</li><li>服务器接受请求，处理请求生成html代码，返回浏览器，这时的html页面代码可能是经过压缩的</li><li>浏览器接受服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li><li>解析过程分为：解析HTML，构建DOM树，DON树与CSS样式进行附着构造呈现树，布局，绘制</li></ul><h2 id="详细过程："><a href="#详细过程：" class="headerlink" title="详细过程："></a>详细过程：</h2><hr><p>下面让我们扒下各个过程细节的外衣，坦诚相见吧</p><h3 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1.输入地址"></a>1.输入地址</h3><hr><p>浏览器引入了 DNS 预取技术。它是利用现有的 DNS 机制，提前解析网页中可能的网络连接。<br>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了。它会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url ，找到同输入的地址很匹配的项，然后给出智能提示，让你可以补全 url 地址。用户还没有按下 enter 键， 浏览器已经开始使用 DNS 预取技术解析该域名了。<br>对于 chrome 的浏览器，如果有该域名相关的缓存，它会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。如果没有缓存，就还是会重新请求资源。</p><h3 id="2-查询-DNS-查找对应的请求-IP-地址"><a href="#2-查询-DNS-查找对应的请求-IP-地址" class="headerlink" title="2.查询 DNS 查找对应的请求 IP 地址"></a>2.查询 DNS 查找对应的请求 IP 地址</h3><hr><h3 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h3><hr><p><strong>TCP 是一种面向有连接的传输层协议。 它可以保证两端（发送端和接收端）通信主机之间的通信可达。 它能够处理在传输过程中丢包、传输顺序乱掉等异常情况；此外它还能有效利用宽带，缓解网络拥堵。</strong><br>三次握手的步骤：（抽象派）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>在 TCP 连接建立完成之后就可以发送 HTTP 请求了。<br>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）<br>四次挥手的步骤：（抽象派）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><h3 id="4-服务器收到请求并响应-HTTP-请求"><a href="#4-服务器收到请求并响应-HTTP-请求" class="headerlink" title="4.服务器收到请求并响应 HTTP 请求"></a>4.服务器收到请求并响应 HTTP 请求</h3><hr><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。<br>常见状态代码、状态描述、说明：</p><p>200 OK    ：客户端请求成功<br>400 Bad Request  ：客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized ：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  ：服务器收到请求，但是拒绝提供服务<br>404 Not Found  ：请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error ：服务器发生不可预期的错误<br>503 Server Unavailable  ：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h3 id="5-浏览器接收服务器响应结果并处理"><a href="#5-浏览器接收服务器响应结果并处理" class="headerlink" title="5.浏览器接收服务器响应结果并处理"></a>5.浏览器接收服务器响应结果并处理</h3><p>渲染步骤大致可以分为以下几步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建 DOM 树</span><br><span class="line"></span><br><span class="line">2. 解析 CSS ，生成 CSS 规则树</span><br><span class="line"></span><br><span class="line">3. 合并 DOM 树和 CSS 规则，生成 render 树</span><br><span class="line"></span><br><span class="line">4. 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</span><br><span class="line"></span><br><span class="line">5. 绘制 render 树（ paint ），绘制页面像素信息</span><br><span class="line"></span><br><span class="line">6. 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> k-point </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2019/10/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>跨域问题：<br>在前端调试的时候，跨域一直都是一个比较麻烦的问题，这个在之前的文章 关于跨域问题的一个解决方法 中其实已经讨论了一些可以使用的方法。</p><p>如果要使用 JSONP，第一是需要修改的地方比较多，而且也不太符合前端发展的大趋势，如果使用 CORS 的话并没有 application/json 类型。而且更重要的是这只是在前端调试时候的需求，并不是在上线以后的需求，所以对后端有太多的入侵也不好。</p><p>所以就有一个念想突然在大脑中闪过——加入有一个代理不就可以解决这个问题了？但是又想了一下写起来还挺麻烦，于是就被搁置了。</p><p>直到前几天 Stone 提到其实 webpack-dev-server 早就想到并且已经帮我们实现了。</p><p>于是，我就在一个 Vue 项目中进行测试，发现真的很赞，既可以本地 Server 热加载，还可以直接跨域调用远程 API，完美解决了之前遇到的所有问题。</p><p>接下来我简要介绍一下步骤（以一个 Vue 脚手架建立的 webpack 项目为例）：</p><p>首先检查 build/webpack.dev.conf.js 中是否有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy: config.dev.proxyTable,</span><br></pre></td></tr></table></figure><p>这个配置项，如果被注释掉，请打开注释，如果没有，请加入到 devServer 对象中</p><p>然后在 config/index.js 中的 dev 对象中加入 proxyTable 配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">   <span class="string">'/**'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://api.xxx.com'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    secure: <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>前面的键 /** 意思是代理所有请求，如果代理某些请求，可以将其改为诸如 /api 之类的字符串。</p><p>后面的 target 就是要代理到的网站，changeOrigin 的意思就是把 http 请求中的 Origin 字段进行变换，在浏览器接收到后端回复的时候，浏览器会以为这是本地请求，而在后端那边会以为是在站内的调用。</p><p>这样，通过这个简单的配置，就完美地解决了跨域的问题。</p><p>之后，在直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>的时候，就可以将测试前端中的 ajax 请求代理到后端服务器进行测试啦！</p>]]></content>
      
      
      <categories>
          
          <category> k-point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 路由</title>
      <link href="/2019/09/08/react%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/09/08/react%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>创建React环境<br>npm install -g create-react-app 全局环境<br>create-react-app my-app  创建项目</p><p>cd my-app 进入项目<br>npm start  启动</p><p><code>什么是路由？</code><br>        路由是根据不同的 url 地址展示不同的内容或页面。</p><p><code>React Router</code><br>        一个针对React而设计的路由解决方案、可以友好的帮你解决React components 到URl之间的同步映射关系。</p><p>安装依赖   使用2.8.1版本的依赖<br>低版本依赖  npm i react@15 react-dom@15 react-router@2 axios –save-dev<br>npm install <a href="mailto:react-router@2.8.1" target="_blank" rel="noopener">react-router@2.8.1</a> -D<br>配合 react/react-dom  15.6.1版本使用</p><p>import React from ‘react’<br>import ReactDOM from ‘react-dom’<br>import { Router, Route, Link, hashHistory} from ‘react-router’<br>react-router中定义了history这个属性 用于方便管理路由的方向 browserHistory／ hashHistory</p><p><code>定义连接组件</code><br>定义链接的组件，类似于a标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link   to=“/users&gt;users&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">&#123;this.props.children&#125;＝＝相当于路由试图的容器</span></span><br></pre></td></tr></table></figure><p><code>导航标签应用</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引一下导航标签</span></span><br><span class="line"><span class="keyword">import</span> &#123;Link&#125; <span class="keyword">from</span> <span class="string">"react-router"</span></span><br><span class="line">&lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link to="/</span>about<span class="string">"&gt;关于&lt;/Link&gt;</span></span><br></pre></td></tr></table></figure><p>``导入路由和规则`</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入路由对象，和规则,</span></span><br><span class="line"><span class="keyword">import</span> &#123;Router,Route,hashHistory&#125; <span class="keyword">from</span> <span class="string">"react-router"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"./views/Home"</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">"./views/About"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在router定义路由规则,代表当前整个路由对象，使用hash模式的路由.</span></span><br><span class="line"><span class="comment">// 每个route上面，有一个path,代表路由规则的路径，不需要嵌套的时候，</span></span><br><span class="line"><span class="comment">// 写单标签就可以，嵌套的时候写双标签</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;hashHistory&#125;</span>&gt;</span></span></span><br><span class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</span><br><span class="line">        &lt;Route path="/home" component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path="/about" component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p><code>重定向的基本配置</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;hashHistory&#125;</span>&gt;</span></span></span><br><span class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</span><br><span class="line">        &#123;/* 在某一个路径下，默认展示试图域名不显示 */&#125;</span><br><span class="line">        &#123;/* &lt;IndexRoute component=&#123;Home&#125; /&gt; */&#125;</span><br><span class="line">        &#123;/* Redirect是跟路径，从哪来。跳到另一个路径，直接跳过 </span><br><span class="line">        &lt;Redirect from="/home" to="/about" /&gt;*/&#125;</span><br><span class="line">        &#123;/* 访问到根路径以后，重新访问到 该路径 */&#125;</span><br><span class="line">        &lt;IndexRedirect to="/home" /&gt;</span><br></pre></td></tr></table></figure><p><code>修改行间样式</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> active = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;路由<span class="number">2.0</span>版本&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;Link to="/</span>home<span class="string">" activeStyle=&#123;active&#125;&gt;首页&lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;Link to="</span>/about<span class="string">" activeStyle=&#123;active&#125;&gt;关于&lt;/Link&gt;</span></span><br></pre></td></tr></table></figure><p><code>传参 props传参</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line"> &lt;div key=&#123;i&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>"/<span class="attr">detail</span>/" + <span class="attr">item.pid</span>&#125;&gt;</span>&#123;item.pname&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> )</span><br><span class="line"> 路由也需要站位符，给个id</span><br><span class="line"> &lt;Route path=<span class="string">"/detail/:id"</span> component=&#123;Detail&#125; /&gt;</span><br><span class="line"> 接收参数的话，可以打印</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.props)</span><br></pre></td></tr></table></figure><p> <code>在组件内部，展示详情列表，</code><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最新的额值，更新获得详情</span></span><br><span class="line">   componentWillReceiveProps(a) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(a.params.id)</span><br><span class="line">       api.getdetail(&#123; <span class="attr">id</span>: a.props.params.id &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(data.data)</span><br><span class="line">           <span class="keyword">this</span>.setState(&#123; <span class="attr">detail</span>: data.data &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><code>query的传参</code><br>接收数据，和传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// console.log(this.props.params.id)</span></span><br><span class="line">        api.getdetail(&#123; <span class="attr">id</span>: <span class="keyword">this</span>.props.location.query.id &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data.data)</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123; <span class="attr">detail</span>: data.data &#125;) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最新的额值，更新获得详情</span></span><br><span class="line">    componentWillReceiveProps(a) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a.params.id)</span><br><span class="line">        api.getdetail(&#123; <span class="attr">id</span>: a.location.query.id &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data.data)</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123; <span class="attr">detail</span>: data.data &#125;)</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>hashHistory</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;hashHistory&#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">About</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    tap() &#123;</span><br><span class="line">        hashHistory.push(<span class="string">"/home"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;about&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;this.tap.bind(this)&#125;&gt;跳转home&lt;/</span>button&gt;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Flux,Vuex,Redux的对比</title>
      <link href="/2019/09/05/%E5%85%B3%E4%BA%8EFlux,Vuex,Redux%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/09/05/%E5%85%B3%E4%BA%8EFlux,Vuex,Redux%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="数据管理工具Flux、Redux、Vuex的区别"><a href="#数据管理工具Flux、Redux、Vuex的区别" class="headerlink" title="数据管理工具Flux、Redux、Vuex的区别:"></a>数据管理工具Flux、Redux、Vuex的区别:</h2><p>为什么要进行数据管理？</p><p>组件式开发的核心思路是MVC，Model层的数据发生变化，驱动View层的视图发生变化。<strong>试想一个场景，如果ModelA触发ModelB变化，导致ViewB发生变化，ViewB发生变化时，触发了ModelC变化，ModelC又触发了其他Model的变化…，我们想知道一个View的变化究竟是那个数据导致的，</strong>追查起来就很困难，于是就记录数据的变化就很有必要了，其实换一个高大上的名字就是数据状态管理。</p><h3 id="怎么有效地进行数据管理？"><a href="#怎么有效地进行数据管理？" class="headerlink" title="怎么有效地进行数据管理？"></a>怎么有效地进行数据管理？</h3><ol><li>数据集中管理<br>view中的数据统一放置到一个仓库（store）中，要渲染页面的时候，从中取出当前状态的数据（state），然后将state中的最新的数据通过props传递到组件中，然后渲染组件，实现试图展现。</li><li>精细化拆解数据操作<br>要修改store中的state，为了做到数据的操作可追溯，尽量将数据的操作拆解成一个个小函数，当然纯函数最好。</li><li>单向数据驱动<br>组件中不能直接修改state的值，修改state，只能发出修改请求（action），由action触发数据操作。</li></ol><p>总之，数据集中管理就需要应用<strong>使用唯一的数据Tree，存放在store中</strong>；精细化拆解数据操作就是<strong>需要提供小而纯的函数，来修改state</strong>；单就向数据驱动需要<strong>提供唯一能修改state的渠道</strong>。</p><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><hr><p>Flux数据流的顺序是:<br>View发起Action-&gt;Action传递到Dispatcher-&gt;Dispatcher将通知Store-&gt;Store的状态改变通知View进行改变<br><img src="https://ask.qcloudimg.com/http-save/yehe-1217459/5gw6kqmjk8.png?imageView2/2/w/1620" alt="图示"><br>ps:<a href="https://github.com/flyer-dev/flux_learn" target="_blank" rel="noopener">基于Flux架构思想写的一个小demo</a></p><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><hr><p>Redux相对于Flux的改进：</p><ul><li>把store和Dispatcher合并,结构更加简单清晰</li><li>新增state角色，代表每个时间点store对应的值，对状态的管理更加明确<br>Redux数据流的顺序是:<br>View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数<br><img src="https://ask.qcloudimg.com/http-save/yehe-1217459/xihbsyzesb.png?imageView2/2/w/1620" alt="图示"><br>ps:<a href="https://github.com/reduxjs/redux/tree/master/examples/counter" target="_blank" rel="noopener">阮一峰老师的Redux+React小demo</a></li></ul><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><hr><p>Vuex是专门为Vue设计的状态管理框架,<br>同样基于Flux架构，并吸收了Redux的优点</p><p>Vuex相对于Redux的不同点有:</p><ul><li>改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，<br>无需switch,只需在对应的mutation函数里改变state值即可</li><li>由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li></ul><p>Vuex数据流的顺序是:<br>View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变(vue检测到数据变化自动渲染)<br><img src="https://ask.qcloudimg.com/http-save/yehe-1217459/ez8jggvm26.png?imageView2/2/w/1620" alt="图示"><br>ps:<a href="https://jsfiddle.net/yyx990803/n9jmu5v7/" target="_blank" rel="noopener">Vuex官方文档上的小demo</a></p><hr><h2 id="使用数据管理工具的场景"><a href="#使用数据管理工具的场景" class="headerlink" title="使用数据管理工具的场景"></a>使用数据管理工具的场景</h2><p>数据管理主要是方便SPA开发时，管理多个组件或子页面的公用数据，如果仅仅是简单个的单页，您最好不要使用Redux或Vuex。</p>]]></content>
      
      
      <categories>
          
          <category> k-point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flux </tag>
            
            <tag> vuex </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack搭建一个react环境</title>
      <link href="/2019/09/04/%E7%94%A8webpack%E6%90%AD%E5%BB%BAreact/"/>
      <url>/2019/09/04/%E7%94%A8webpack%E6%90%AD%E5%BB%BAreact/</url>
      
        <content type="html"><![CDATA[<ol><li><p>生成package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li><p>用webpack构建react环境,装webpack三大环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-dev-serve react react-dom --save-dev</span><br></pre></td></tr></table></figure></li><li><p>建基础文件</p></li></ol><ul><li><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件webpack.config.js</p></li><li><p>入口文件main.js</p></li><li><p>根主件App.js</p></li><li><p><em>注意：*</em><br>js模块如果使用es6语言编写 安装babel依赖(编译babel语言)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader@7 babel-core babel-preset-react webpack --save-dev</span><br></pre></td></tr></table></figure></li></ul><p>并在官网把配置代码加入webpack.config.js中<br>同时在webpack.config.js添加<code>修改端口：devserver</code><br>最后添加HtmlWebpackPlugin的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><h2 id="为了方便阅读，我把文件贴在下面"><a href="#为了方便阅读，我把文件贴在下面" class="headerlink" title="为了方便阅读，我把文件贴在下面"></a>为了方便阅读，我把文件贴在下面</h2><p>main.js和App.js都放在根目录下src文件夹中<br>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span> ;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>,document.getElementById("app"))</span></span><br></pre></td></tr></table></figure><hr><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./css/common.css'</span></span><br><span class="line"><span class="comment">// import img from './img/1.img'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2 className=<span class="string">'tit'</span>&gt;React webpack&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;hello&lt;/</span>p&gt;</span><br><span class="line">                &#123;<span class="comment">/* &lt;img src=&#123;img&#125;/&gt; */</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><hr><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">'react'</span>,<span class="string">'es2015'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    compress:<span class="literal">true</span>,</span><br><span class="line">    port:<span class="number">9000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="comment">//html模板</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">"./index.html"</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置json文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ol><p>最后，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础（二）</title>
      <link href="/2019/08/02/React%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2019/08/02/React%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="无状态组件-hook-受控组件-amp-非受控组件-数据流"><a href="#无状态组件-hook-受控组件-amp-非受控组件-数据流" class="headerlink" title="无状态组件  hook 受控组件&amp;非受控组件 数据流"></a>无状态组件  hook 受控组件&amp;非受控组件 数据流</h1><p>在React中创建组件有三种方式：<br><code>ES5写法：React.createClass</code><br><code>ES6写法：React.Component</code><br>无状态的函数写法，又称为纯组件SFC<br>vue相比之下：是注册组件和创建组件<br>无状态组件的优势：<br>1.代码整洁，易读<br>2.无状态,无this,无绑定<br>3.便于测试<br>4.性能高<br>无状态的函数创建的组件是无状态组件，它是一种只负责展示的纯组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;无状态组件。函数组件，纯组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br></pre></td></tr></table></figure><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。主要是：可以在函数组件内创建局部状态，以及模拟生命周期函数<br><code>核心对象 useState   useEffect</code></p><p>useState可以在function定义的组件中设置一个局部状态，返回两个值<br>第一个是状态的名字，第二个为改变状态的方法<br>Egs：  const [count,setCount] = useState(0)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;无状态组件。函数组件，纯组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;&#123;props.name&#125;&lt;/</span>div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;count&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;修改&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(<span class="string">"hello"</span>)&#125;&gt;修改&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useEffect可以在function定义的组件中模拟组件生命周期函数，两个参数<br>第一个是回调函数，第二个执行回调函数的触发条件(array)，空表示只执行一次(无代表多次)</p><p>Egs：useEffect(()=&gt;{<br>    console.log(‘only one’)<br>},[])<br>只要组件没有参数，一直点击按钮是一直在触发的,如果后面放一个空数组就不会再一直触发了,可以依赖某个变量来决定触发的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [user,setState]=useState(<span class="string">"小妖精"</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count)</span><br><span class="line">    &#125;, [count])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;无状态组件。函数组件，纯组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;&#123;props.name&#125;&lt;/</span>div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;count&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;修改&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(<span class="string">"星星眼"</span>)&#125;&gt;修改&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h1 id="受控组件-amp-非受控组件"><a href="#受控组件-amp-非受控组件" class="headerlink" title="受控组件&amp;非受控组件"></a>受控组件&amp;非受控组件</h1><p>主要是用于表单<br>input上是value值是不可控的，<br>不可改变value里面的值，<br>1.加上defaultValue（是新属性）是可以改变的值，是受的<br>2.也可以，给其绑定个事件，用原生，可以变成受控的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tap(e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            val: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;受控、非受控&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;input type="text" defaultValue=&#123;this.state.val&#125; onChange=&#123;(e) =&gt; this.tap(e)&#125; /</span>&gt;</span><br><span class="line">                &#123;<span class="comment">/* &lt;button onClick=&#123;this.tap.bind(this)&#125;&gt;控制&lt;/button&gt; */</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>1、数据从父组件流向子组件<br>2、子组件数据流向父组件<br>ref获取dom元素  ref给dom添加该属性，通过this.refs.ref的值获取dom</p><p>绑定ref ,refs取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">"./Child"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    tap() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.tit.innerHTML)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.ipt.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2 ref=<span class="string">"tit"</span>&gt;父组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;input type="text" ref="ipt" /</span>&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.tap.bind(<span class="keyword">this</span>)&#125;&gt;获取dom&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;hr /</span>&gt;</span><br><span class="line">                &lt;Child /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>父组件=&gt;子组件传值 在组件的标签上绑定自定义属性，值为父组件需要传递的数据，子组件通过props接收<br>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">        val: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tap() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        val: <span class="keyword">this</span>.refs.ipt.value</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// console.log(this.refs.tit.innerHTML)</span></span><br><span class="line">    <span class="comment">// console.log(this.refs.ipt.value)</span></span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2 ref=<span class="string">"tit"</span>&gt;父组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;input type="text" ref="ipt" /</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.tap.bind(<span class="keyword">this</span>)&#125;&gt;获取dom&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;hr /</span>&gt;</span><br><span class="line">            &lt;Child name=&#123;<span class="keyword">this</span>.state.val&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>子组件代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.name)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2 ref=<span class="string">"tit"</span>&gt;子组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;&#123;this.props.name&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>子组件=&gt;向父组件传值：组件间传值流向只能借助于组件的状态，写上去的都是属性，反向的数据传值只能借助于回调函数参数的形式进行传递<br>子组件代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">send() &#123;</span><br><span class="line">        <span class="comment">// this.props.title == function</span></span><br><span class="line">        <span class="comment">// this.props.title() == function ()</span></span><br><span class="line">        <span class="comment">// this.props.titl（xx） == function (111)</span></span><br><span class="line">        <span class="comment">// this.refs.ipt.value=111</span></span><br><span class="line">        <span class="keyword">this</span>.props.title(<span class="keyword">this</span>.refs.ipt.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.name)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2 ref=<span class="string">"tit"</span>&gt;子组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;&#123;this.props.name&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> ref=<span class="string">"ipt"</span> /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.send.bind(<span class="keyword">this</span>)&#125;&gt;传值给父组件&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>父组件代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">           val: <span class="string">""</span>,</span><br><span class="line">           str: <span class="string">""</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   tap() &#123;</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">           val: <span class="keyword">this</span>.refs.ipt.value</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="comment">// console.log(this.refs.tit.innerHTML)</span></span><br><span class="line">       <span class="comment">// console.log(this.refs.ipt.value)</span></span><br><span class="line">   &#125;</span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;h2 ref=<span class="string">"tit"</span>&gt;父组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">               &lt;p&gt;接收子组价数据：&#123;this.state.str&#125;&lt;/</span>p&gt;</span><br><span class="line">               &lt;input type=<span class="string">"text"</span> ref=<span class="string">"ipt"</span> /&gt;</span><br><span class="line">               &lt;button onClick=&#123;<span class="keyword">this</span>.tap.bind(<span class="keyword">this</span>)&#125;&gt;获取dom&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">               &lt;hr /</span>&gt;</span><br><span class="line">               &lt;Child name=&#123;<span class="keyword">this</span>.state.val&#125; title=&#123;<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">                   _this.setState(&#123; <span class="attr">str</span>: msg &#125;)</span><br><span class="line">               &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础（一）</title>
      <link href="/2019/08/01/React%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2019/08/01/React%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="React基础知识"><a href="#React基础知识" class="headerlink" title="React基础知识"></a>React基础知识</h1><hr><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr><p>本章节将从React的特点、如何使用React、JSX语法，然后会对组件(Component）以及组件的属性(props)、状态(state)、生命周期等方面进行讲解。</p><h3 id="通过本章节能学到什么？"><a href="#通过本章节能学到什么？" class="headerlink" title="通过本章节能学到什么？"></a>通过本章节能学到什么？</h3><hr><ul><li>对React有个全面的认识；</li><li>熟悉JSX基本语法；</li><li>了解组件结构；</li><li>熟悉组件的生命周期；</li><li>学会使用props；</li><li>学会使用state；</li><li>熟悉自定义组件；<h3 id="React是什么？"><a href="#React是什么？" class="headerlink" title="React是什么？"></a>React是什么？</h3></li></ul><hr><p>React 是 Facebook 推出的开源 JavaScript Library，它是一个用于组建用户界面的JavaScript库，让你以更简单的方式来创建交互式用户界面，它的出现让许多革新性的 Web 观念开始流行起来，例如：Virtual DOM、Component，声明式渲染等。<br><br>声明式与命令式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。</span><br><span class="line"><span class="number">2.</span> 声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/crazycodeboy/pen/VVJLYm" target="_blank" rel="noopener">演示</a></p><ol><li>当数据改变时，React将高效的更新和渲染需要更新的组件。声明式视图使你的代码更可预测，更容易调试。</li><li>构建封装管理自己的状态的组件，然后将它们组装成复杂的用户界面。由于组件逻辑是用JavaScript编写的，而不是模板，所以你可以轻松地通过您的应用程序传递丰富的数据，并保持DOM状态。<h3 id="自动搭建脚手架"><a href="#自动搭建脚手架" class="headerlink" title="自动搭建脚手架"></a>自动搭建脚手架</h3></li></ol><hr><p>构建一个新的 React 单页应用，可以通过<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">Create React App</a>来完成。它可以帮助你配置开发环境，以便你可以使用最新的 JavaScript 特性，还能提供一个友好的开发体验，并为生产环境优化你的应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^16.6.3&quot;,//是 React 的核心库</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.6.3&quot;,//提供与 DOM 相关的功能</span><br><span class="line">    &quot;react-scripts&quot;: &quot;2.1.1&quot;//create-react-app 的一个核心包，一些脚本和工具的默认配置都集成在里面</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><hr><p><code>ReactDOM.render(element, container[, callback])</code><br>渲染一个 React 元素到由 container 提供的 DOM 中，并且返回组件的一个 引用(reference) （或者对于 无状态组件 返回 null ）。</p><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><hr><p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 每一个XML标签都会被JSX转换工具转换成纯JavaScript代码，使用JSX，组件的结构和组件之间的关系看上去更加清晰。 JSX并不是React必须使用的，但React官方建议我们使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。<br><strong>Usage:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">React.render(           //使用JSX</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;content&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;,</span><br><span class="line">    document.getElementById(&apos;example&apos;)</span><br><span class="line">);</span><br><span class="line">React.render(           //不使用JSX</span><br><span class="line">    React.createElement(&apos;div&apos;, null,</span><br><span class="line">        React.createElement(&apos;div&apos;, null,</span><br><span class="line">            React.createElement(&apos;div&apos;, null, &apos;content&apos;)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    document.getElementById(&apos;example&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="组件的属性-props"><a href="#组件的属性-props" class="headerlink" title="组件的属性(props)"></a>组件的属性(props)</h3><p>我们可以通过this.props.xx的形式获取组件对象的属性，对象的属性可以任意定义，但要避免与JavaScript关键字冲突。</p><h4 id="遍历组件的属性"><a href="#遍历组件的属性" class="headerlink" title="遍历组件的属性:"></a>遍历组件的属性:</h4><p>this.props.children会返回组件对象的所有属性。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用React.Children.map或React.Children.forEach来遍历子节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotesList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ol&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    React.Children.map(<span class="keyword">this</span>.props.children,(child)=&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;                     </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/ol&gt;         </span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;NotesList&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;hello&lt;/</span>span&gt;     </span><br><span class="line">    &lt;span&gt;world&lt;<span class="regexp">/span&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/</span>NotesList&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h4 id="ref-属性-获取真实的DOM节点"><a href="#ref-属性-获取真实的DOM节点" class="headerlink" title="ref 属性(获取真实的DOM节点)"></a>ref 属性(获取真实的DOM节点)</h4><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。</p><p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Todolist</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            list:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;TodoList&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;input type='text' ref='ipt'/</span>&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.add.bind(<span class="keyword">this</span>)&#125;&gt;添加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;</span></span><br><span class="line"><span class="regexp">                    this.state.list.map((item,i)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                        return(</span></span><br><span class="line"><span class="regexp">                            &lt;div key=&#123;i&#125;&gt;&#123;item&#125;---&lt;button onClick=&#123;this.delete.bind(this,i)&#125;&gt;删除&lt;/</span>button&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                        )</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    add()&#123;</span></span><br><span class="line"><span class="regexp">        let arr = this.state.list</span></span><br><span class="line"><span class="regexp">        arr.push(this.refs.ipt.value)</span></span><br><span class="line"><span class="regexp">        console.log(arr)</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;list:arr&#125;)</span></span><br><span class="line"><span class="regexp">        this.refs.ipt.value=''</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    delete(i) &#123;</span></span><br><span class="line"><span class="regexp">      console.log(i)</span></span><br><span class="line"><span class="regexp">      let arr1 = this.state.list</span></span><br><span class="line"><span class="regexp">      arr1.splice(i,1)</span></span><br><span class="line"><span class="regexp">      this.setState(&#123; list: arr1 &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>上文讲到了props，组件会根据props的变化来进行渲染，但组件无法改变自身的props，那么组件为了实现交互，可以使用组件的 state 。state 是组件私有的，可以通过state={}方式初始化，通过调用 this.setState() 来改变它。当 state 更新之后，组件就会重新渲染自己。</p><h2 id="render-方法依赖于-this-props-和-this-state-，框架会确保渲染出来的-UI-界面总是与输入（-this-props-和-this-state-）保持一致。"><a href="#render-方法依赖于-this-props-和-this-state-，框架会确保渲染出来的-UI-界面总是与输入（-this-props-和-this-state-）保持一致。" class="headerlink" title="render() 方法依赖于 this.props 和 this.state ，框架会确保渲染出来的 UI 界面总是与输入（ this.props 和 this.state ）保持一致。"></a>render() 方法依赖于 this.props 和 this.state ，框架会确保渲染出来的 UI 界面总是与输入（ this.props 和 this.state ）保持一致。</h2><h3 id="初始化state"><a href="#初始化state" class="headerlink" title="初始化state"></a>初始化state</h3><p>可以通过一下两种方式来初始化state，在组件的生命周期中仅执行一次，用于设置组件的初始化 state 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">        name:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">state=&#123;</span><br><span class="line">    name:<span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新-state"><a href="#更新-state" class="headerlink" title="更新 state"></a>更新 state</h3><p>通过this.setState()方法来更新state，调用该方法后，React会重新渲染相关的UI。<br>this.setState({favorite:!this.state.favorite});</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FavoriteButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">   state=&#123;</span><br><span class="line">       favorite:<span class="literal">false</span></span><br><span class="line">   &#125;;</span><br><span class="line">    handleClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">favorite</span>:!<span class="keyword">this</span>.state.favorite&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> text=<span class="keyword">this</span>.state.favorite? <span class="string">'favorite'</span>:<span class="string">'un favorite'</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;h1 onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">                You &#123;text&#125; <span class="keyword">this</span>. Click to toggle.</span><br><span class="line">            &lt;<span class="regexp">/h1&gt;         );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码是一个 FavoriteButton 组件，它的通过 state={}初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">心得：由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。</span><br><span class="line">一个简单的区分方法是，this.props 表示那些本组件无法改变的特性，而 this.state 是会随着用户互动而产生变化的特性。</span><br></pre></td></tr></table></figure><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="https://upload-images.jianshu.io/upload_images/5287253-82f6af8e0cc9012b.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="react生命周期"></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由知识点</title>
      <link href="/2018/09/03/vue%E5%85%B3%E4%BA%8E%E8%B7%AF%E7%94%B1/"/>
      <url>/2018/09/03/vue%E5%85%B3%E4%BA%8E%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="路由用什么模式？hash跟history区别，怎么转换？"><a href="#路由用什么模式？hash跟history区别，怎么转换？" class="headerlink" title="路由用什么模式？hash跟history区别，怎么转换？"></a>路由用什么模式？hash跟history区别，怎么转换？</h3><blockquote><p>对于 Vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。</p></blockquote><p>为了达到这一目的，浏览器当前提供了以下两种支持：<br><strong>hash模式和history模式</strong></p><h4 id="hash模式："><a href="#hash模式：" class="headerlink" title="hash模式："></a>hash模式：</h4><p>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</p><h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式:"></a>history模式:</h4><h2 id="history采用HTML5的新特性；且提供了两个新方法：-pushState-，replaceState-可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。"><a href="#history采用HTML5的新特性；且提供了两个新方法：-pushState-，replaceState-可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。" class="headerlink" title="history采用HTML5的新特性；且提供了两个新方法： pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。"></a>history采用HTML5的新特性；且提供了两个新方法： pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</h2><h3 id="路由拦截在项目中做什么功能的时候用到了？怎么用的？"><a href="#路由拦截在项目中做什么功能的时候用到了？怎么用的？" class="headerlink" title="路由拦截在项目中做什么功能的时候用到了？怎么用的？"></a>路由拦截在项目中做什么功能的时候用到了？怎么用的？</h3><p>登录拦截逻辑<br><strong>第一步：路由拦截</strong><br>首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由，<br>否则就进入登录页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        name: <span class="string">'/'</span>,</span><br><span class="line">        component: Index</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/repository'</span>,</span><br><span class="line">        name: <span class="string">'repository'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            requireAuth: <span class="literal">true</span>,  <span class="comment">// 添加该字段，表示进入这个路由是需要登录的</span></span><br><span class="line">        &#125;,</span><br><span class="line">        component: Repository</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        component: Login</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>定义完路由后，我们主要是利用vue-router提供的钩子函数beforeEach()对路由进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.meta.requireAuth) &#123;  <span class="comment">// 判断该路由是否需要登录权限</span></span><br><span class="line">        <span class="keyword">if</span> (store.state.token) &#123;  <span class="comment">// 通过vuex state获取当前的token是否存在</span></span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            next(&#123;</span><br><span class="line">                path: <span class="string">'/login'</span>,</span><br><span class="line">                query: &#123;<span class="attr">redirect</span>: to.fullPath&#125;  <span class="comment">// 将跳转的路由path作为参数，登录成功后跳转到该路由</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>每个钩子方法接收三个参数：<br>to: Route: 即将要进入的目标 路由对象<br>from: Route: 当前导航正要离开的路由<br>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<br><strong>确保要调用 next 方法，否则钩子就不会被 resolved。</strong><br>其中，to.meta中是我们自定义的数据，其中就包括我们刚刚定义的requireAuth字段。通过这个字段来判断该路由是否需要登录权限。需要的话，同时当前应用不存在token，则跳转到登录页面，进行登录。登录成功后跳转到目标路由。</p><p>登录拦截到这里就结束了吗？并没有。这种方式只是简单的前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。<br>这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。</p><p><strong>第二步：拦截器</strong><br>要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置http response inteceptor，当后端接口返回401 Unauthorized（未授权），让用户重新登录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (store.state.token) &#123;  <span class="comment">// 判断是否存在token，如果存在的话，则每个http header都加上token</span></span><br><span class="line">            config.headers.Authorization = <span class="string">`token <span class="subst">$&#123;store.state.token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// http response 拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (error.response.status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                    <span class="comment">// 返回 401 清除token信息并跳转到登录页面</span></span><br><span class="line">                    store.commit(types.LOGOUT);</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: <span class="string">'login'</span>,</span><br><span class="line">                        query: &#123;<span class="attr">redirect</span>: router.currentRoute.fullPath&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)   <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="命名路由的好处是什么？"><a href="#命名路由的好处是什么？" class="headerlink" title="命名路由的好处是什么？"></a>命名路由的好处是什么？</h3><p>官方文档的解释：<a href="https://router.vuejs.org/zh/guide/essentials/named-routes.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/essentials/named-routes.html</a><br>就是在routers配置路由名称的时候给路由定义不同的名字，这样的好处就是可以在使用router-link的to属性跳转路由的时候传一个对象从而实现与router.push一样的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue-2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目技术小记</title>
      <link href="/2018/09/01/vue%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
      <url>/2018/09/01/vue%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="最近做的项目快要结尾了，本项目用前后端分离的，然后前端是用vue开发的，为什么选vue呢？一来公司要求效率要高些的，那就应该用到三大流行的框架之一，然后项目的内容不太复杂的，觉得用vue更合适的。二来正好应该要“炒熟”vue了哈。其中陷入了不少坑，一个一个爬过来的，总结下入坑的原因，另外会给出官方文档的对应内容，以便加深理解的。如有不足之处，请提出来哈～"><a href="#最近做的项目快要结尾了，本项目用前后端分离的，然后前端是用vue开发的，为什么选vue呢？一来公司要求效率要高些的，那就应该用到三大流行的框架之一，然后项目的内容不太复杂的，觉得用vue更合适的。二来正好应该要“炒熟”vue了哈。其中陷入了不少坑，一个一个爬过来的，总结下入坑的原因，另外会给出官方文档的对应内容，以便加深理解的。如有不足之处，请提出来哈～" class="headerlink" title="最近做的项目快要结尾了，本项目用前后端分离的，然后前端是用vue开发的，为什么选vue呢？一来公司要求效率要高些的，那就应该用到三大流行的框架之一，然后项目的内容不太复杂的，觉得用vue更合适的。二来正好应该要“炒熟”vue了哈。其中陷入了不少坑，一个一个爬过来的，总结下入坑的原因，另外会给出官方文档的对应内容，以便加深理解的。如有不足之处，请提出来哈～"></a>最近做的<del>项目快要结尾了</del>，本项目用前后端分离的，然后前端是用vue开发的，为什么选vue呢？一来公司要求效率要高些的，那就应该用到三大流行的框架之一，然后项目的内容不太复杂的，觉得用vue更合适的。二来正好应该要“炒熟”vue了哈。其中陷入了不少坑，一个一个爬过来的，总结下入坑的原因，另外会给出官方文档的对应内容，以便加深理解的。如有不足之处，请提出来哈～</h2><h3 id="异步加载组件"><a href="#异步加载组件" class="headerlink" title="异步加载组件"></a>异步加载组件</h3><p>我们都知道vue一般都是单页面的，也就意味着一开始就要加载全部的组件，这太不友好的，加载时间会慢些。这时候我们就用到异步组件～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router= <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path:<span class="string">'/login'</span>,</span><br><span class="line">      name:<span class="string">'Login'</span>,</span><br><span class="line">      component:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'../views/Login'</span>),<span class="comment">//路由懒加载</span></span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: <span class="string">'登录'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vue指令：非常好用，谁用谁知道"><a href="#vue指令：非常好用，谁用谁知道" class="headerlink" title="vue指令：非常好用，谁用谁知道"></a>vue指令：非常好用，谁用谁知道</h3><p>v-for 用于遍历<br>v-if &amp; v-show 用于隐藏和显示元素(区别在于后者是修改 display:block|none,前者是不创建把元素从dom中删除或者创建.<br>v-bind: 属性绑定,把数据绑定在HTML元素的属性上.<br>v-html &amp; v-text 把数据绑定在HTML元素的属性上,作用同 innerHTML &amp; innerText<br>v-on: 绑定HTML元素事件<br>v-if &amp; v-else-if &amp; v-else 条件渲染</p><h2 id="v-model-绑定表单元素-实现双向绑定"><a href="#v-model-绑定表单元素-实现双向绑定" class="headerlink" title="v-model 绑定表单元素,实现双向绑定"></a>v-model 绑定表单元素,实现双向绑定</h2><h3 id="vue自定义指令："><a href="#vue自定义指令：" class="headerlink" title="vue自定义指令："></a>vue自定义指令：</h3><p>应用场景：<br>element-ui中有个模态框用的是它自定义的指令v-loading，想要同样的效果可以用Vue核心组件中的自定义指令模块。<br>看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div v-test:user.isman.ischinese = <span class="string">"123"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"1234"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// @ is an alias to /src</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        directives: &#123;</span><br><span class="line">            test: &#123;</span><br><span class="line">                bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">                    el.innerHTML = <span class="string">'&lt;h1&gt;指令内容&lt;/h1&gt;'</span> + binding.expression</span><br><span class="line">                    <span class="built_in">console</span>.log(el)</span><br><span class="line">                    <span class="built_in">console</span>.log(binding)</span><br><span class="line">                    <span class="built_in">console</span>.log(vnode)</span><br><span class="line">                    <span class="built_in">console</span>.log(oldVnode)</span><br><span class="line">                &#125;,</span><br><span class="line">                inserted() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                update() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                componentUpdated() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                unbind() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>directives是一个对象，里面包含了各个指令，每个指令也是个对象，可以在里面自定义配置（比如上面代码中的test{…}，test在模板里面的表现就是v-test）。</p><h4 id="每个指令的解析"><a href="#每个指令的解析" class="headerlink" title="每个指令的解析"></a>每个指令的解析</h4><p>生命周期（钩子，Hook）<br>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</p><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p><h2 id="unbind：只调用一次，指令与元素解绑时调用。"><a href="#unbind：只调用一次，指令与元素解绑时调用。" class="headerlink" title="unbind：只调用一次，指令与元素解绑时调用。"></a>unbind：只调用一次，指令与元素解绑时调用。</h2><h3 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h3><p>在vue中提供了Vue.filter(‘flterName’,fn)来定义一个过滤器，过滤器可以在HTML代码中使用，如对动态拿到的数据进行过滤，<br>一个简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"price"</span>&gt;</span><br><span class="line">        &#123;&#123;price | currency(<span class="string">'$'</span>)&#125;&#125;&lt;!--通过‘|’管道符来过滤前面的price--&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.6</span><span class="number">.10</span>/vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    Vue.filter('currency',function(val,unit)&#123;//定义过滤器，并定义功能。</span></span><br><span class="line"><span class="string">        val =  val || 0;</span></span><br><span class="line"><span class="string">        unit = unit || '元';</span></span><br><span class="line"><span class="string">        return val + unit;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    new Vue(&#123;</span></span><br><span class="line"><span class="string">        el:'.demo',</span></span><br><span class="line"><span class="string">        data:&#123;</span></span><br><span class="line"><span class="string">            price:'',</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>Vuex 类似 Redux 的状态管理器，vuex是一个专门为vue.js设计的集中式状态管理架构，用来管理Vue的所有组件状态。我认为就是前端为了方便数据的操作而建立的一个“前端数据库”。</p><h2 id="Vuex基本使用的总结"><a href="#Vuex基本使用的总结" class="headerlink" title="Vuex基本使用的总结"></a><a href="https://www.jianshu.com/p/aae7fee46c36" target="_blank" rel="noopener">Vuex基本使用的总结</a></h2><h3 id="vue生命周期函数"><a href="#vue生命周期函数" class="headerlink" title="vue生命周期函数"></a>vue生命周期函数</h3><p>|钩子函数        |描述                                                            |<br>|beforeCreate    |组件实例刚被创建，组件属性计算之前，如data属性等                    |<br>|created        |组件实例创建完成，属性已绑定，但DOM还未生成，$el属性还不存在            |<br>|beforeMount    |模板编译 / 挂载之前                                                |<br>|mounted        |模板编译 / 挂载之后                                                |<br>|beforeUpdate    |组件更新之前                                                        |<br>|update            |组件更新之后                                                        |<br>|activated        |组件被激活时调用                                                    |<br>|deactivated    |组件被移除时调用                                                    |<br>|beforeDestory    |组件销毁前调用                                                    |<br>|destoryed        |组件销毁后调用                                                    |</p><p><strong>日常举栗子</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"https://cdn.jsdelivr.net/vue/2.1.3/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div id="app"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"change()"</span>&gt;change&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="destr()"&gt;destroy&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">        el: '#app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            message: 66</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        beforeCreate: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('beforeCreate 创建前');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        created: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('created 创建完毕');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data + JSON.stringify(this.$data));</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        beforeMount: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('beforeMount 挂载前');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        mounted: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('mounted 挂载结束');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        beforeUpdate: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('beforeUpdate 更新前');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        updated: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('updated 更新完成');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        beforeDestroy: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('beforeDestroy 销毁前');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        destroyed: function () &#123;</span></span><br><span class="line"><span class="string">            console.group('destroyed 销毁完成');</span></span><br><span class="line"><span class="string">            console.log("</span>el: <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">            console.log("</span>data: <span class="string">" + this.$data);</span></span><br><span class="line"><span class="string">            console.log("</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods: &#123;</span></span><br><span class="line"><span class="string">            change() &#123;</span></span><br><span class="line"><span class="string">                app.message++;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            destr() &#123;</span></span><br><span class="line"><span class="string">                app.$destroy();</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>可以在控制台上感受一下。</p>]]></content>
      
      
      <categories>
          
          <category> vue-2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue技术栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue传值传参小结</title>
      <link href="/2018/08/03/vue%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/03/vue%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="vue中做什么功能用到了组件件传值？传值方式有哪些？怎么实现的？"><a href="#vue中做什么功能用到了组件件传值？传值方式有哪些？怎么实现的？" class="headerlink" title="vue中做什么功能用到了组件件传值？传值方式有哪些？怎么实现的？"></a>vue中做什么功能用到了组件件传值？传值方式有哪些？怎么实现的？</h4><p>VUE中组件之间传值，总结来讲有三种情况，分别是：父组件对子组件、子组件对父组件以及兄弟组件之间传值以及调用。</p><blockquote><p>父组件传值给子组件:通过类似于属性绑定的方式，将需要传入子组件中的数据，绑定在子组件上，子组件通过props接收传入进来的数据。<br>父组件中可以给子组件传入一个静态的值：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但一般我们都是需要传动态的值，所以需要v-bind绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">//也可以写成</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">:title</span>=<span class="string">"post.title+'by'+post.author.name"</span>&gt;</span><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件要显式的用props选项声明它预期的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个子组件中：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'hello world'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子组件传值给父组件<br>通过事件派发的方式传值给父组件，或者告知父组件需要调用方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值：</span></span><br><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt;</span><br><span class="line">      &lt;test-com @childFn=<span class="string">"parentFn"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">test-com</span>&gt;</span></span></span><br><span class="line">      &lt;br/&gt; </span><br><span class="line">      子组件传来的值 : &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">       parentFn(payload) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = payload;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。</span></span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt; </span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"testCom"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"message"</span> /&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"click"</span>&gt;Send&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 默认</span></span><br><span class="line"><span class="regexp">          message: '我是来自子组件的消息'</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      click() &#123;</span></span><br><span class="line"><span class="regexp">            this.$emit('childFn', this.message);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="vue路由-路由传参数有哪些方法？项目中传递什么数据用哪种传参？"><a href="#vue路由-路由传参数有哪些方法？项目中传递什么数据用哪种传参？" class="headerlink" title="vue路由  路由传参数有哪些方法？项目中传递什么数据用哪种传参？"></a>vue路由  路由传参数有哪些方法？项目中传递什么数据用哪种传参？</h4><h3 id="一-使用router-link进行路由导航，传递参数"><a href="#一-使用router-link进行路由导航，传递参数" class="headerlink" title="一.使用router-link进行路由导航，传递参数"></a>一.使用router-link进行路由导航，传递参数</h3><blockquote><p>父组件中：使用<router-link to="/需要跳转的路由路径/需要传递的参数"></router-link>标签进行导航</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/child/123"</span>&gt;</span><span class="tag">&lt;<span class="name">el-button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- child是子页面路由路径，123是需要传递的参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>子组件中：使用this.$route.params.num来接收路由参数</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">&#123;&#123;num&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="actionscript">name:<span class="string">'child'</span>,</span></span><br><span class="line">data:&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span>&#123;</span></span><br><span class="line">num:0</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.num=<span class="keyword">this</span>.$route.params.num  <span class="comment">//123</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此时，页面上渲染出路由传递过来的参数num，呈现123 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>地址栏中：localhost:8080/#/child/123(在地址栏中显示传递的参数num,即123, ，刷新页面，参数不丢失)</p></blockquote><h3 id="二、直接调用-router-push-实现携带参数的跳转"><a href="#二、直接调用-router-push-实现携带参数的跳转" class="headerlink" title="二、直接调用$router.push 实现携带参数的跳转"></a>二、直接调用$router.push 实现携带参数的跳转</h3><blockquote><p>父组件中：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"itemId in 3"</span> <span class="attr">:key</span>=<span class="string">"itemId"</span> @<span class="attr">click</span>=<span class="string">"toChild(itemId)"</span>&gt;</span>&#123;&#123;itemId&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="actionscript">name:<span class="string">"home"</span>,</span></span><br><span class="line">data()&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span>&#123;&#125;</span></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">toChild(id)&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$router.push(&#123;</span></span><br><span class="line"><span class="javascript">path:<span class="string">`/child/<span class="subst">$&#123;id&#125;</span>`</span></span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模板渲染中调用函数，传递参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>子组件中：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">&#123;&#123;this.$route.params.id&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 仍然使用 this.$route.params.id  获取参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>路由配置文件中：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:&apos;/child/:id&apos;,</span><br><span class="line">name:&apos;child&apos;,</span><br><span class="line">component:Child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>id用来为参数占位,在地址栏中显示传递的参数id, 刷新页面，参数不丢失</p><h3 id="三、通过路由属性中的name来确定匹配的路由，通过params来传递参数"><a href="#三、通过路由属性中的name来确定匹配的路由，通过params来传递参数" class="headerlink" title="三、通过路由属性中的name来确定匹配的路由，通过params来传递参数"></a>三、通过路由属性中的name来确定匹配的路由，通过params来传递参数</h3><blockquote><p>父组件中:</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"toChild"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="actionscript">name:<span class="string">'home'</span>,</span></span><br><span class="line">data()&#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">toChild()&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$router.push(&#123;</span></span><br><span class="line"><span class="actionscript">name:<span class="string">'childView'</span>,</span></span><br><span class="line">params:&#123;</span><br><span class="line">id:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用name来匹配路由 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>子组件中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">&#123;&#123;this.$route.params.id&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 依然使用 this.$route.params.id  接收参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>路由配置文件中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:<span class="string">'/child'</span>,</span><br><span class="line">name:<span class="string">'childView'</span>,</span><br><span class="line">component:Child</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用name匹配</span></span><br></pre></td></tr></table></figure><p>地址栏中：localhost:8080/#/child(地址栏中不显示参数，刷新页面，参数丢失)</p><h3 id="使用path来匹配路由，然后通过query来传递参数，这种情况下-query传递的参数会显示在url后面-id-？"><a href="#使用path来匹配路由，然后通过query来传递参数，这种情况下-query传递的参数会显示在url后面-id-？" class="headerlink" title="使用path来匹配路由，然后通过query来传递参数，这种情况下 query传递的参数会显示在url后面?id=？"></a>使用path来匹配路由，然后通过query来传递参数，这种情况下 query传递的参数会显示在url后面?id=？</h3><blockquote><p>父组件中：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"toChild"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="actionscript">name:<span class="string">'home'</span>,</span></span><br><span class="line">data()&#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">toChild()&#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$router.push(&#123;</span></span><br><span class="line"><span class="actionscript">path:<span class="string">'/child'</span>,</span></span><br><span class="line">query:&#123;</span><br><span class="line">id:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用query来传递参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>子组件中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">&#123;&#123;this.$route.query.id&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 this.$route.query.id来接收参数 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>路由配置文件中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:<span class="string">'/child'</span>,</span><br><span class="line">name:<span class="string">'child'</span>,</span><br><span class="line">component:Child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址栏中：localhost:8080/#/child?id=1(参数显示在地址栏中，刷新页面参数不丢失)</p><p>****这里要特别注意 ：在子组件中 获取参数的时候是$route.params 而不是$router ，这很重要<del>~</del></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、 this.$router.push进行编程式路由跳转</p><p>2、 router-link 进行页面按钮式路由跳转</p><p>3、 this.$route.params获取路由传递参数</p><p>4、this.$route.query获取路由传递参数</p><p>5、 params 和 query 都是传递参数的，params不会在url上面出现，并且params参数是路由的一部分，是一定要存在的 query则是我们通常看到的url后面的跟在？后面的显示参数</p>]]></content>
      
      
      <categories>
          
          <category> vue-2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传值与传参 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中的底层原理</title>
      <link href="/2018/08/01/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2018/08/01/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vue实现双向绑定原理"><a href="#vue实现双向绑定原理" class="headerlink" title="vue实现双向绑定原理"></a>vue实现双向绑定原理</h1><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>vue数据双向绑定通过‘数据劫持’ + 订阅发布模式实现</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果</p><p>典型的有<br>1.Object.defineProperty()<br>2.es6中Proxy对象</p><h3 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h3><p>定义：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知<br>订阅发布模式中事件统一由处理中心处理，订阅者发布者互不干扰。<br>优点：实现更多的控制，做权限处理，节流控制之类，例如：发布了很多消息，但是不是所有订阅者都要接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个处理中心</span></span><br><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  clientList: &#123;&#125;, <span class="comment">// 订阅事件列表</span></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  on(key, fn)&#123;</span><br><span class="line">    <span class="comment">// 如果这个事件没有被订阅，那么创建一个列表用来存放事件</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将事件放入已有的事件列表中</span></span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  trigger(type, args)&#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.clientList[type] <span class="comment">// 拿到这个事件的所有监听</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;  <span class="comment">// 如果没有这条消息的订阅者</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在这个事件的订阅，那么遍历事件列表，触发对应监听</span></span><br><span class="line">    fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 可以在此处添加过滤等处理</span></span><br><span class="line">      fn(args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>很多前端新人谈到vue的双向绑定回想到v-model，其实我们应该谈谈双向绑定的逻辑，一句话概括起来就是：</p><blockquote><p>在数据渲染时使用prop渲染数据，将prop绑定到子组件自身的数据上，修改数据时更新自身数据来替代prop，watch子组件自身数据的改变，触发事件通知父组件更改绑定到prop的数据。</p></blockquote><p>再往下谈<strong>Vue数据绑定这样做的好处是什么</strong></p><blockquote><p>敲黑板划重点：父组件数据改变时，不会修改存储prop的子组件数据，只是以子组件数据为媒介，完成对prop的双向修改。</p></blockquote><h2 id="关于axios的实现原理可以看我在js里面总结的基于Promise对Ajax原理-进行简单封装"><a href="#关于axios的实现原理可以看我在js里面总结的基于Promise对Ajax原理-进行简单封装" class="headerlink" title="关于axios的实现原理可以看我在js里面总结的基于Promise对Ajax原理 进行简单封装"></a>关于axios的实现原理可以看我在js里面总结的<strong>基于Promise对Ajax原理 进行简单封装</strong></h2><h2 id="关于vue项目中用axios出现跨域问题以及和ajax的区别："><a href="#关于vue项目中用axios出现跨域问题以及和ajax的区别：" class="headerlink" title="关于vue项目中用axios出现跨域问题以及和ajax的区别："></a>关于vue项目中用axios出现跨域问题以及和ajax的区别：</h2><p>对于跨域问题，前端一般是不负责解决的，都是交给后台来解决。<br>可以采用以下方式进行解决：<br>1：服务器端设置跨域<br>2：可以自己设置一个代理服务器<br>另外，在express中发起请求就可以避免跨域问题的出现。</p><p>axios.js Vue官方推荐的ajax库<br>vue-resource插件已经官方推荐中去掉</p><blockquote><p>fetch.js fetch是基于Promise的,未来的趋势。<br>axios.js Vue 2.0 官方推荐。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue-2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 双向绑定 </tag>
            
            <tag> axios底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之常用数组</title>
      <link href="/2017/12/08/javascript%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84/"/>
      <url>/2017/12/08/javascript%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组方法总结："><a href="#数组方法总结：" class="headerlink" title="数组方法总结："></a>数组方法总结：</h2><hr><p>总结一下 JavaScript 中数组 Array 常用的一些方法：</p><ol><li><p>创建数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = []</span><br><span class="line">var arr = new Array()</span><br></pre></td></tr></table></figure></li><li><p>join()（原数组不变）</p></li></ol><p><strong>数组 -&gt; 字符串</strong>，默认用逗号为分隔符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = arr.join()        <span class="comment">// 数组变字符串， 以逗号分开</span></span><br><span class="line"><span class="keyword">var</span> str = arr.join(<span class="string">''</span>)        <span class="comment">// 数组变字符串， 不添加任何东西</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">b = a.join(<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><p><strong>字符串 -&gt; 数组</strong>，默认用逗号为分隔符,需要用到String对象中的split()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">"1,2,3,4"</span>;</span><br><span class="line"><span class="keyword">var</span> c=a.split(<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>push() 和 pop()（原数组改变）<br>push()：接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<br>pop() ： 数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p></li><li><p>shift() 和 unshift()（原数组改变）<br>shift()： 删除原数组第一项，并返回删除元素的值；如果数组为空则返回 undefined ；<br>Unshift()：将参数添加到原数组开头，并返回数组的长度 。</p></li><li><p>sort() (原数组改变)<br>按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;]</span><br><span class="line">arr1.sort())      // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">arr2 = [13, 24, 51, 3]</span><br><span class="line">arr2.sort())      // [13, 24, 3, 51] , 按第一位数字排序</span><br><span class="line">arr.sort((a, b) =&gt; &#123; return a - b &#125;)       // [3, 13, 24, 51] , 升序</span><br><span class="line">arr.sort((a, b) =&gt; &#123; return b - a &#125;)       // [51, 24, 13, 3] ， 降序</span><br></pre></td></tr></table></figure></li><li><p>slice() （原数组没变）<br>返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">var _arr = arr.slice(1, 3)       // [2 , 3], 返回 （3 - 1） = 2 个元素的数组</span><br></pre></td></tr></table></figure></li><li><p>splice() (原数组改变)<br>删除： 删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。</p></li></ol><p><strong>splice(0, 2)    //删除数组中的前两项。返回值为删除的元素（数组形式）</strong><br>插入： 向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。<br><strong>splice(2, 0, 4, 6)   //从当前数组的位置 2 开始插入4和6。返回值为空（数组形式）</strong><br>替换： 向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。<br><strong>splice (2, 1, 4, 6)    // 删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。返回值为删除的元素（数组形式）</strong></p><ol start="8"><li><p>indexOf() 和 lastIndexOf()<br>indexOf()：接收一或两个参数：要查找的项和（可选的）表示查找起点位置的索引。默认从数组的开头（位置 0）开始向后查找。<br>lastIndexOf：接收一或两个参数：要查找的项和（可选的）表示查找起点位置的索引。默认从数组的末尾开始向前查找。</p></li><li><p>map() (原数组没变)<br>“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">var arr2 = arr.map((item) =&gt; &#123; </span><br><span class="line">  return item*item</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)    // [1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></li><li><p>filter() (原数组没变)<br>“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">var _arr = arr.filter((item) =&gt; &#123; return item &gt;= 3 &#125;)         // [3, 4, 5]</span><br></pre></td></tr></table></figure></li><li><p>reverse()（原数组改变）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">arr.reverse()       // [3, 2, 1]</span><br></pre></td></tr></table></figure></li><li><p>数组扁平化<br>(1) map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = []</span><br><span class="line">    arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            res = res.concat(flatten(item))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>(2) [].concat<br>es6的扩展运算符能将二维数组变为一维</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].concat(...[1, 2, 3, [4, 5]])         // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>根据这个结果我们可以做一个遍历，若arr中含有数组则使用一次扩展运算符，直至没有为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之关于拷贝</title>
      <link href="/2017/12/07/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/12/07/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝以及实现方式"><a href="#深拷贝与浅拷贝以及实现方式" class="headerlink" title="深拷贝与浅拷贝以及实现方式"></a>深拷贝与浅拷贝以及实现方式</h1><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p><strong>浅拷贝将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用</strong>（拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响）</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝是将原对象的各个属性的“值”逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上（注意拷贝的“值”而不是“引用”）</p></blockquote><h3 id="什么时候使用深拷贝"><a href="#什么时候使用深拷贝" class="headerlink" title="什么时候使用深拷贝?"></a>什么时候使用深拷贝?</h3><blockquote><p>我们在希望改变新的数组（对象）的时候，不改变原数组（对象）</p></blockquote><h3 id="使用深拷贝的注意事项"><a href="#使用深拷贝的注意事项" class="headerlink" title="使用深拷贝的注意事项"></a>使用深拷贝的注意事项</h3><blockquote><p>如果对象比较大，层级也比较多，深拷贝会带来性能上的问题。所以在遇到需要使用深拷贝，考虑有没有其他的方案，实际应用中主要还是以浅拷贝为主</p></blockquote><hr><h3 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h3><ul><li><p><strong>自定义函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1)<span class="comment">//&#123;a:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123;a:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> obj1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1)<span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Object.assign()</strong><br>Object.assign我们经常会用到合并对象，当然利用Object.assign性质我们也可以实现对象的拷贝。<br>这里要注意的是Object.assign第一个参数必须是个空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line">obj2.a = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1)<span class="comment">//&#123;a:1,b:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123;a:4,b:2&#125;</span></span><br><span class="line"><span class="comment">//Object.assign()进行的拷贝是浅拷贝,只有第一层是深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line">obj2.b.c = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1)<span class="comment">//&#123;a:1,b:&#123;c:4&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123;a:1,b:&#123;c:4&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解构赋值</strong><br>解构赋值和Object.assign()拷贝方式一样，只有第一层是深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;...obj1&#125;</span><br><span class="line">obj2.a = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)<span class="comment">//&#123;a:1,b:2&#125;,&#123;a:4,b:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = [&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    childs: [<span class="string">'小李'</span>, <span class="string">'小王'</span>]</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">var</span> obj2 = [...obj1]</span><br><span class="line">obj2[<span class="number">0</span>].childs = [<span class="string">'小杨'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)<span class="comment">//[&#123;name: '张三',childs: ['小杨']&#125;]</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h3><hr><ul><li><strong>利用json.stringify</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = [&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    childs: [<span class="string">'小李'</span>, <span class="string">'小王'</span>]</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line">obj2[<span class="number">0</span>].childs = [<span class="string">'小杨'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line"><span class="comment">//obj1：[&#123;name: '张三',childs: ['小李', '小王']&#125;]</span></span><br><span class="line"><span class="comment">//obj1：[&#123;name: '张三',childs: ['小杨']&#125;]</span></span><br></pre></td></tr></table></figure></li></ul><p>但是这种方法存在一种弊端，结果值为undefined,或者function的时候并不会拷贝过来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = [&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    childs: [<span class="string">'小李'</span>, <span class="string">'小王'</span>],</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    age: <span class="literal">undefined</span></span><br><span class="line">&#125;]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line"> </span><br><span class="line">obj2[<span class="number">0</span>].childs = [<span class="string">'小杨'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br></pre></td></tr></table></figure><hr><ul><li><strong>利用递归来实现一个方法进行拷贝</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = [&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    childs: [<span class="string">'小王'</span>, <span class="string">'小李'</span>],</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    age: <span class="literal">undefined</span></span><br><span class="line">&#125;]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj2 = extend(obj1)</span><br><span class="line"> </span><br><span class="line">obj2[<span class="number">0</span>].childs = [<span class="string">'小杨'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'object'</span> &amp;&amp; data) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">typeof</span> data.length === <span class="string">'number'</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> data) &#123;</span><br><span class="line">        val[i] = extend(data[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样我们就能把所有值都拷贝过来了。    </p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 深拷贝&amp;浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之ajax</title>
      <link href="/2017/12/06/javascript%E4%B9%8Bajax/"/>
      <url>/2017/12/06/javascript%E4%B9%8Bajax/</url>
      
        <content type="html"><![CDATA[<h2 id="ajax的底层交互原理以及ajax的简单封装"><a href="#ajax的底层交互原理以及ajax的简单封装" class="headerlink" title="ajax的底层交互原理以及ajax的简单封装"></a>ajax的底层交互原理以及ajax的简单封装</h2><hr><p>AJAX即“Asyn Javascript And XML”，是指一种创建交互式网页应用的网页开发技术。<br>Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。<br>Ajax的目的是提高用户体验，较少网络数据的传输量。<br><img src="/img/3174701-cdb67e435d967ec3.jpg" alt="AJAX"></p><h3 id="Ajax的使用"><a href="#Ajax的使用" class="headerlink" title="Ajax的使用"></a>Ajax的使用</h3><h4 id="1-创建Ajax核心对象XMLHttpRequest-记得考虑兼容性"><a href="#1-创建Ajax核心对象XMLHttpRequest-记得考虑兼容性" class="headerlink" title="1.创建Ajax核心对象XMLHttpRequest(记得考虑兼容性)"></a>1.创建Ajax核心对象XMLHttpRequest(记得考虑兼容性)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> xhr=<span class="literal">null</span>;  </span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)  </span><br><span class="line"><span class="number">3.</span>   &#123;<span class="comment">// 兼容 IE7+, Firefox, Chrome, Opera, Safari  </span></span><br><span class="line"><span class="number">4.</span>   xhr=<span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line"><span class="number">5.</span>   &#125; <span class="keyword">else</span>&#123;<span class="comment">// 兼容 IE6, IE5 </span></span><br><span class="line"><span class="number">6.</span>     xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);  </span><br><span class="line"><span class="number">7.</span>   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2.向服务器发送请求"></a>2.向服务器发送请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> xhr.open(method,url,<span class="keyword">async</span>);  </span><br><span class="line"><span class="number">2.</span> send(string);<span class="comment">//post请求时才使用字符串参数，否则不用带参数。</span></span><br></pre></td></tr></table></figure><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul><p><strong>注意：post请求一定要设置请求头的格式内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"POST"</span>,<span class="string">"test.html"</span>,<span class="literal">true</span>);  </span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);  </span><br><span class="line">xhr.send(<span class="string">"fname=Henry&amp;lname=Ford"</span>);  <span class="comment">//post请求参数放在send里面，即请求体</span></span><br></pre></td></tr></table></figure><h4 id="3-服务器响应处理（区分同步跟异步两种情况）"><a href="#3-服务器响应处理（区分同步跟异步两种情况）" class="headerlink" title="3.服务器响应处理（区分同步跟异步两种情况）"></a>3.服务器响应处理（区分同步跟异步两种情况）</h4><p><strong>①同步处理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> xhr.open(<span class="string">"GET"</span>,<span class="string">"info.txt"</span>,<span class="literal">false</span>);  </span><br><span class="line"><span class="number">2.</span> xhr.send();  </span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xhr.responseText; <span class="comment">//获取数据直接显示在页面上</span></span><br></pre></td></tr></table></figure><p><strong>②异步处理</strong><br>相对来说比较复杂，要在请求状态改变事件中处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span>&#123; </span><br><span class="line"><span class="number">2.</span>    <span class="keyword">if</span> (xhr.readyState==<span class="number">4</span> &amp;&amp;xhr.status==<span class="number">200</span>)  &#123; </span><br><span class="line"><span class="number">3.</span>       <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xhr.responseText;  </span><br><span class="line"><span class="number">4.</span>      &#125;</span><br><span class="line"><span class="number">5.</span>    &#125;</span><br></pre></td></tr></table></figure><p><strong>③GET和POST请求数据区别</strong></p><ul><li>使用Get请求时,参数在URL中显示,而使用Post方式,则放在send里面</li><li>使用Get请求发送数据量小,Post请求发送数据量大</li><li>使用Get请求安全性低，会被缓存，而Post请求反之<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'/list?page=5'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></li></ul><p>GET请求参数需要拼在url上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'POST'</span>,<span class="string">'/list'</span>);</span><br><span class="line">xhr.send(<span class="string">'page=5&amp;pageSize=20'</span>)</span><br></pre></td></tr></table></figure><h2 id="POST请求数据是放在send里面的"><a href="#POST请求数据是放在send里面的" class="headerlink" title="POST请求数据是放在send里面的"></a>POST请求数据是放在send里面的</h2><p>PS:<br><strong>什么是readyState？</strong><br>readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。<br>readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义</p><ul><li>0：未初始化 – 尚未调用.open()方法；</li><li>1：启动 – 已经调用.open()方法，但尚未调用.send()方法；</li><li>2：发送 – 已经调用.send()方法，但尚未接收到响应；</li><li>3：接收 – 已经接收到部分响应数据；</li><li>4：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了；</li></ul><p><strong>什么是status？</strong><br>HTTP状态码(status)由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><h2 id="status"><a href="#status" class="headerlink" title="status"></a><a href="https://baike.baidu.com/item/HTTP状态码/5053660?fr=aladdin" target="_blank" rel="noopener">status</a></h2><h2 id="ajax和axios、fetch的区别"><a href="#ajax和axios、fetch的区别" class="headerlink" title="ajax和axios、fetch的区别"></a>ajax和axios、fetch的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">type:<span class="string">"get"</span>,</span><br><span class="line">url:<span class="string">""</span>,</span><br><span class="line"><span class="keyword">async</span>:<span class="literal">true</span>,</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">dataType:<span class="string">""</span>,</span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>AJAX:<br>是基于XHR原生开发的，目前已有的fetch可替代。本身是针对mvc的编程模式，不太适合目前mvvm的编程模式。jQuery本身比较大，如果单纯的使用ajax可以自己封装一个，不然会影响性能体验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AXIOS:<br>从浏览器中创XMLHttpRequest请求。<br>node.js中创建http请求。<br>自动转换为json数据类型<br>支持promise API ，提供了一些并发请求的接口。<br>是vue全家桶技术之一，在vue中需要使用npm install axios –save-dev来安装依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> data = response.json();</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</span><br></pre></td></tr></table></figure><p>FETCH:<br>脱离了xhr。<br>是es规范里新的实现方式。<br>更加底层，提供了丰富的API。<br>.fetch没有办法原生监测请求的进度，而XHR可以。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ajax是最早出现发送后端请求的技术，属于原生js范畴,核心是使用XMLHttpRequest对象,使用较多并有先后顺序的话，容易产生回调地狱。</p><p>fetch号称可以代替ajax的技术，是基于es6中的Promise对象设计的，参数和jQuery中的ajax类似，它并不是对ajax进一步封装，它属于原生js范畴。没有使用XMLHttpRequest对象。</p><p>axios不是原生js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和相应阶段进行拦截，基于promise对象。</p><p><a href="https://www.jianshu.com/p/4cfbb0ed6cd1" target="_blank" rel="noopener">简单封装AJAX</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax交互 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之promise</title>
      <link href="/2017/12/05/javascript%E4%B9%8Bpromise/"/>
      <url>/2017/12/05/javascript%E4%B9%8Bpromise/</url>
      
        <content type="html"><![CDATA[<h2 id="promise-你必须知道这些东西"><a href="#promise-你必须知道这些东西" class="headerlink" title="promise,你必须知道这些东西"></a>promise,你必须知道这些东西</h2><p>首先，要想知道promise是怎么用的，我们要知道为什么会有promise的出现，</p><p>在实际的使用当中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。最重要也是最主要的一个场景就是ajax请求。通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的ajax原生实现</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10'</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) &#123;</span><br><span class="line">        result = XHR.response;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到我们想要的数据，之后我们才能开始处理数据。<br>这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就不得不如下这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10'</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) &#123;</span><br><span class="line">        result = XHR.response;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">        <span class="keyword">var</span> url2 = <span class="string">'http:xxx.yyy.com/zzz?ddd='</span> + result.someParams;</span><br><span class="line">        <span class="keyword">var</span> XHR2 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        XHR2.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">        XHR2.send();</span><br><span class="line">        XHR2.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当出现第三个ajax-甚至更多-仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为回调地狱。"><a href="#当出现第三个ajax-甚至更多-仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为回调地狱。" class="headerlink" title="当出现第三个ajax(甚至更多)仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为回调地狱。"></a>当出现第三个ajax(甚至更多)仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为<strong>回调地狱。</strong></h2><p>因此我们需要一个叫做Promise的东西，来解决这个问题。<br><strong>为了我们的代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来。</strong></p><h4 id="那么，promise到底是怎么用的呢"><a href="#那么，promise到底是怎么用的呢" class="headerlink" title="那么，promise到底是怎么用的呢?"></a>那么，promise到底是怎么用的呢?</h4><p>新建一个Promise对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//some code</span></span><br><span class="line">    <span class="keyword">if</span>(success)&#123; <span class="comment">//异步操作成功</span></span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//异步操作失败</span></span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise构造函数接收一个函数作为参数，它的两个参数resolve和reject，是两个函数，由JavaScript引擎提供，不用自己部署。</p><p>resolve函数的作用是：将Promise的状态从“pending”变为“resolve”，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；</p><p>reject函数的作用是：将Promise状态从“pending”变为“reject”，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p><p><strong>axios就是基于Promise的用于浏览器和node的http客户端，下面是在所作项目中axios的用法，是搜索页面的接口。其中的then就是resolve的内容，catch就是reject的内容。</strong>当然，self.getRequest是用axios封装后的全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">'search/'</span> + self.searchType;</span><br><span class="line">               <span class="keyword">let</span> model = &#123;&#125;;</span><br><span class="line">               <span class="keyword">let</span> page = self.currentPage - <span class="number">1</span>;</span><br><span class="line">               model = &#123;</span><br><span class="line">                   searchValue: self.searchValue,</span><br><span class="line">                   page: page,</span><br><span class="line">                   size: <span class="number">10</span>,</span><br><span class="line">                   operatingStatus: self.operatingStatus,</span><br><span class="line">                   establishTimeType: self.establishTimeType,</span><br><span class="line">               &#125;;</span><br><span class="line">               self.getRequest(url, model).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                   self.successCallBack(res);</span><br><span class="line">               &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(err);</span><br><span class="line">                   self.nodata = <span class="literal">true</span>;</span><br><span class="line">                   self.loading = <span class="literal">false</span>;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>异步操作抛出错误状态成reject，或then方法指定的回调函数中发生错误，就会被catch方法捕获。Promise的错误具有冒泡性质，可以一直向后传递到被最后一个catch捕获。</p><p><strong>封装axios的get请求，作为全局变量使用。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getRequest = <span class="function">(<span class="params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> axios(&#123;</span><br><span class="line"></span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line"></span><br><span class="line">      url: url,</span><br><span class="line"></span><br><span class="line">      params: params,</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之es6新增</title>
      <link href="/2017/12/04/javascript%E4%B9%8Bes6%E6%96%B0%E5%A2%9E/"/>
      <url>/2017/12/04/javascript%E4%B9%8Bes6%E6%96%B0%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6常用的新增技术"><a href="#ES6常用的新增技术" class="headerlink" title="ES6常用的新增技术"></a>ES6常用的新增技术</h1><hr><h2 id="this的指向性"><a href="#this的指向性" class="headerlink" title="this的指向性"></a>this的指向性</h2><p>首先我们需要得出一个非常重要一定要牢记于心的结论，<strong>this的指向，是在函数被调用的时候确定的。</strong>也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 10</span></span><br><span class="line">fn.call(obj); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>除此之外，<strong>在函数执行过程中，this一旦被确定，就不可更改了。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span> = obj; <span class="comment">// 这句话试图修改this，运行后会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><hr><p><strong>使用call，apply显示指定this</strong><br>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p><p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj);</span><br></pre></td></tr></table></figure><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj, <span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 130</span></span><br><span class="line">fn.apply(obj, [<span class="number">20</span>, <span class="number">10</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><ul><li>实现继承<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父级的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, high</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use call</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name:'</span>+<span class="keyword">this</span>.name+<span class="string">', age:'</span>+<span class="keyword">this</span>.age+<span class="string">', high:'</span>+<span class="keyword">this</span>.high+<span class="string">', gender:'</span>+<span class="keyword">this</span>.gender[<span class="number">0</span>]+<span class="string">';'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Student(<span class="string">'xiaom'</span>, <span class="number">12</span>, <span class="string">'150cm'</span>).message();</span><br></pre></td></tr></table></figure></li></ul><p>在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">    <span class="comment">// Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承</span></span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外就是借助闭包与apply方法，封装一个bind方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(bind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        &#125;, <span class="keyword">this</span>), <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><hr><ul><li><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let实际上为 JavaScript 新增了块级作用域。var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p></li><li><p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p></li><li><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p></li><li><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p></li></ul><h2 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数 =&gt;"></a>箭头函数 =&gt;</h2><hr><p>ES6 允许使用“箭头”（=&gt;）定义函数。<br>箭头函数有几个使用注意点。<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。</p><h2 id="变量解构（解构赋值）"><a href="#变量解构（解构赋值）" class="headerlink" title="变量解构（解构赋值）"></a>变量解构（解构赋值）</h2><hr><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样。<br>解构不仅可以用于数组，还可以用于对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><hr><p><em>模板字符串（template string）是增强版的字符串</em><br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> sum = a + b;</span><br><span class="line"><span class="keyword">var</span> res = a + <span class="string">'+'</span> + b + <span class="string">'的和是&lt;b&gt;'</span> + c+<span class="string">'&lt;/b&gt;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">box.innerHTML = res;</span><br><span class="line"><span class="keyword">var</span> obj=  &#123;<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&lt;b&gt;姓名&lt;/b&gt;：'</span>+obj.name+<span class="string">'&lt;b&gt;年龄&lt;/b&gt;:'</span>+obj.age;</span><br><span class="line">div.innerHTML = str;</span><br></pre></td></tr></table></figure><p>ES6写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> sum = a + b;</span><br><span class="line"><span class="keyword">var</span> res = <span class="string">`a+b的和是&lt;b&gt;<span class="subst">$&#123;c&#125;</span>&lt;/b&gt;`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">box.innerHTML = res;</span><br><span class="line"><span class="keyword">var</span> obj=  &#123;<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> str =<span class="string">`&lt;b&gt;姓名&lt;/b&gt;：<span class="subst">$&#123;obj.name&#125;</span>&lt;b&gt;年龄&lt;/b&gt;:<span class="subst">$&#123;obj.age&#125;</span>`</span></span><br><span class="line">div.innerHTML = str;</span><br></pre></td></tr></table></figure><h2 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h2><hr><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）<br>下面是一个类似数组的对象，Array.from将它转为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><hr><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; ...[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] &#125;;</span><br><span class="line">foo</span><br><span class="line"><span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="class的写法及继承"><a href="#class的写法及继承" class="headerlink" title="class的写法及继承"></a>class的写法及继承</h2><hr><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。<br>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>类方法<br>加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>类的继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之关于闭包</title>
      <link href="/2017/12/03/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/"/>
      <url>/2017/12/03/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>当一个函数能够记住并访问到其所在的词法作用域及作用域链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包。</p><p>需要明确的几点：</p><ul><li>闭包一定是函数对象 <a href="https://github.com/wintercn/blog/issues/3" target="_blank" rel="noopener">wintercn大大的闭包考证</a>  </li><li>闭包和词法作用域，作用域链，垃圾回收机制息息相关</li><li>当函数一定是在其定义的作用域外进行的访问时，才产生闭包</li><li>闭包是由该函数和其上层执行上下文共同构成</li></ul><p>内存泄漏：<br><code>我们应该保证执行代码只保存有用的数据，一旦数据不再有用，我们就应该让垃圾回收机制对其进行回收，释放内存。</code><br>闭包阻止了垃圾回收机制对变量进行回收，因此变量会永远存在内存中，即使当变量不再被使用时，这样会造成内存泄漏，会严重影响页面的性能。因此当变量对象不再适用时，我们要将其释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( a );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> bar;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> baz = foo();</span><br><span class="line"> baz(); <span class="comment">//baz指向的对象会永远存在堆内存中</span></span><br><span class="line"> baz = <span class="literal">null</span>; <span class="comment">//如果baz不再使用，将其指向的对象释放</span></span><br></pre></td></tr></table></figure><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>1.模块<br>一个模块应该具有私有属性、私有方法和公有属性、公有方法。<br>而闭包能很好的将模块的公有属性、方法暴露出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"echo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">name,</span><br><span class="line">getName</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log( myModule.name ); <span class="comment">// echo</span></span><br><span class="line"><span class="built_in">console</span>.log( myModule.getName() ); <span class="comment">// echo</span></span><br></pre></td></tr></table></figure><p>“return”关键字将对象引用导出赋值给myModule，从而应用到闭包。</p><p>2.延时器(setTimeout)、计数器(setInterval)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, <span class="number">1000</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>每秒钟输出一个5，一共输出5次。</code><br><code>如何做到每秒钟输出一个数，以此为0，1，2，3，4呢？</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">(<span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, <span class="number">1000</span> * j)</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第一个例子中每次循环中的setTimeout回调函数记住的i的值是for循环作用域中的值，此时都是5，而第二个例子记住的i的数为setTimeout的父级作用域自执行函数中的j的值，依次为0，1，2，3，4。</p><p>3.监听器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySeletor(<span class="string">"#div"</span>);</span><br><span class="line"></span><br><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( oDiv.id );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之关于继承</title>
      <link href="/2017/12/02/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/12/02/javascript%E4%B9%8B%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承-－-原型，原型连，es6继承-，call，apply"><a href="#继承-－-原型，原型连，es6继承-，call，apply" class="headerlink" title="继承 － 原型，原型连，es6继承 ，call，apply"></a>继承 － 原型，原型连，es6继承 ，call，apply</h1><h3 id="属性拷贝"><a href="#属性拷贝" class="headerlink" title="属性拷贝"></a>属性拷贝</h3><p>就是将对象的成员复制一份给需要继承的对象<br>// 创建父对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">  name: <span class="string">'Li'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  friends: [<span class="string">'小明'</span>, <span class="string">'小李'</span>, <span class="string">'小赵'</span>],</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建需要继承的子对象</span></span><br><span class="line"><span class="keyword">var</span> subObj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 开始拷贝属性(使用for...in...循环)</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i <span class="keyword">in</span> superObj )&#123;</span><br><span class="line">  subObj[i] = superObj[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(subObj)</span><br><span class="line"><span class="built_in">console</span>.log(superObj)</span><br></pre></td></tr></table></figure><p>存在问题：<br>如果继承过来的成员是引用类型的话,<br>那么这个引用类型的成员在父对象和子对象之间是共享的,<br>也就是说修改了之后, 父子对象都会受到影响.</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>借用构造函数的原型对象实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置父构造器的原型对象</span></span><br><span class="line">SuperClass.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置子构造函数的原型对象实现继承</span></span><br><span class="line">SubClass.prototype = SuperClass.prototype;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> SubClass()</span><br></pre></td></tr></table></figure><p>问题：<br>父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题<br>只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>即 子构造函数.prototype = new 父构造函数()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'liyajie'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置父构造函数的原型</span></span><br><span class="line">SuperClass.prototype.friends = [<span class="string">'小名'</span>, <span class="string">'小强'</span>];</span><br><span class="line">SuperClass.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"><span class="comment">// 修改子构造函数的原型的构造器属性</span></span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// liyajie</span></span><br><span class="line"><span class="built_in">console</span>.log(child.age);<span class="comment">// 25</span></span><br><span class="line">child.showName();<span class="comment">// liyajie</span></span><br><span class="line">child.showAge();<span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(child.friends); <span class="comment">// ['小名','小强']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们改变friends的时候, 父构造函数的原型对象的也会变化</span></span><br><span class="line">child.friends.push(<span class="string">'小王八'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.friends);[<span class="string">"小名"</span>, <span class="string">"小强"</span>, <span class="string">"小王八"</span>]</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> SuperClass();</span><br><span class="line"><span class="built_in">console</span>.log(father.friends);[<span class="string">"小名"</span>, <span class="string">"小强"</span>, <span class="string">"小王八"</span>]</span><br></pre></td></tr></table></figure><p>问题：<br>不能给父构造函数传递参数，父子构造函数的原型对象之间有共享问题</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>使用call和apply借用其他构造函数的成员, 可以解决给父构造函数传递参数的问题, 但是获取不到父构造函数原型上的成员.也不存在共享问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.freinds = [<span class="string">'小王'</span>, <span class="string">'小强'</span>];</span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 使用call借用Person的构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 测试是否有了 Person 的成员</span></span><br><span class="line"> <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'Li'</span>);</span><br><span class="line"> stu.showName(); <span class="comment">// Li</span></span><br><span class="line"> <span class="built_in">console</span>.log(stu.friends); <span class="comment">// ['小王','小强']</span></span><br></pre></td></tr></table></figure><h3 id="ES6对比"><a href="#ES6对比" class="headerlink" title="ES6对比"></a>ES6对比</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;  <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubPerson</span>(<span class="params">name,job</span>)</span>&#123;  <span class="comment">// 子类</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>,name);  <span class="comment">// 子类继承父类的属性 需要将this指向父类中的name</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;  <span class="comment">// job是子类自己的属性</span></span><br><span class="line">&#125;</span><br><span class="line">SubPerson.prototype = <span class="keyword">new</span> Person();  <span class="comment">// 子类继承父类的方法</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> SubPerson(<span class="string">'ponponpa'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// ponponpa</span></span><br><span class="line"><span class="comment">// console.log(p1.showName());  // ponponpa</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,job)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);    <span class="comment">// 指向父类的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line">    showJob()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.job;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> SubPerson(<span class="string">'ponponpa'</span>,<span class="string">'前端开发'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// ponponpa</span></span><br><span class="line"><span class="comment">// console.log(p1.showName());  // ponponpa</span></span><br><span class="line"><span class="comment">// console.log(p1.job); // 前端开发</span></span><br></pre></td></tr></table></figure><p>extends就代表这继承的意思，super就是指向父类的构造函数，指代了整个prototype对象或者_proto_指针指向的对象，</p><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call(),apply(),bind()"></a>call(),apply(),bind()</h3><p>简单来说：</p><ul><li><blockquote><p>bind</p><blockquote><p>bind(context,arguments) 返回一个函数</p></blockquote></blockquote></li><li><blockquote><p>call</p><blockquote><p>call(context,arg1,arg2…) 指定作用域 同时执行函数</p></blockquote></blockquote></li><li><blockquote><p>apply</p><blockquote><p>apply(context,args) 指定作用域 同时执行函数，后面的参数是数组<br>bind的实现</p></blockquote></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind(context,...args)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.apply(context,args)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>call和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同.</strong><br><strong>除了第一个参数外，call可以接收一个参数列表，apply只接受一个参数数组。 bind绑定完之后返回一个新的函数，不执行。</strong><br>底层原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 执行完后干掉</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 判断 arguments[1] 是不是 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之面向对象及对象的创建</title>
      <link href="/2017/12/01/javascript%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2017/12/01/javascript%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象-amp-面向过程"><a href="#面向对象-amp-面向过程" class="headerlink" title="面向对象&amp;面向过程"></a>面向对象&amp;面向过程</h1><ul><li>面向过程总结:<br>面向过程是一种自上向下的编程。<br>面向过程优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</li><li>面向对象总结:<br>面向对象是将事物高度抽象化。面向对象必须先建立抽象模型，之后直接使用模型就行了。<br>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>缺点：性能比面向过程低</li></ul><h1 id="对象的创建－字面量，原型，构造函数等各自特点"><a href="#对象的创建－字面量，原型，构造函数等各自特点" class="headerlink" title="对象的创建－字面量，原型，构造函数等各自特点"></a>对象的创建－字面量，原型，构造函数等各自特点</h1><ol><li>工厂模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name=name;</span><br><span class="line">  o.age=age;</span><br><span class="line">  o.job=job;</span><br><span class="line">  o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;   <span class="comment">//将创建的对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=createPerson(<span class="string">"Jim"</span>,<span class="number">22</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>缺点：工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（怎样知道一个对象的类型）。</p><ol start="2"><li>构造函数模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.job=job;</span><br><span class="line">  <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">"Jim"</span>,<span class="number">22</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>构造函数模式相对于工厂模式有几个显著的区别<br>（1） 没有显式地创建对象<br>（2）直接将属性和方法赋给了this对象<br>（3）没有return语句<br>（4）函数名的首字母大写（Person和createPerson）：按照惯例，构造函数始终都是以大写字母开头，而非构造函数则应该以小写字母开头</p><p>缺点：ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。而构造函数在每次创建的时候都会完成同样任务的function实例(sayName)，这是很没有必要的。因此可以把函数定义转移到构造函数外部来解决这个问题。</p><ol start="3"><li>原型模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Jim"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">22</span>;</span><br><span class="line">Person.protoType.job=<span class="string">"Doctor"</span>;</span><br><span class="line">Person.protoType.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person();</span><br><span class="line">person.sayName();   <span class="comment">//Jim</span></span><br></pre></td></tr></table></figure></li></ol><p>#可以让所有对象实例共享它所包含的属性和方法。<br>原型语法简单写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  <span class="keyword">constructor</span>:Person,</span><br><span class="line">  name:"Jim",</span><br><span class="line">  age:22,</span><br><span class="line">  job:"Doctor",</span><br><span class="line">  sayName:function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：“共享”性，即当没有对Person的friends赋值时，直接调用原型属性并修改，就会直接导致原型修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  friends:[<span class="string">"Amy"</span>,<span class="string">"Sam"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends);     <span class="comment">//"Amy,Sam,Van"</span></span><br><span class="line">alert(person2.friends);     <span class="comment">//"Amy,Sam,Van"</span></span><br></pre></td></tr></table></figure><p>总结：<br>（1）工厂模式：在函数里面创建对象，并添加属性和方法。但没有解决对象识别问题，最后被构造函数模式所取代。<br>（2）构造函数模式：可以像创建内置对象实例一样使用new操作符。但没函数不局限于任何对象，因此没有了封装性。<br>（3）原型模式：使用构造函数的prototype属性指定应该共享的属性和方法。但单独使用原型模式的话，就会使不需要共享的属性和方法被共享</p><h3 id="构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性"><a href="#构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性" class="headerlink" title="构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性"></a>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性</h3>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Forever</title>
      <link href="/2016/09/28/forever/"/>
      <url>/2016/09/28/forever/</url>
      
        <content type="html"><![CDATA[<hr><p>I saw you                                      </p><p>You smiled warmly                             </p><p>The world began waking up.                     </p><p>初见你</p><p>温婉一笑</p><p>似万物复苏</p><hr><p>梦里梦见你</p><p>梦里梦见梦不见的是你</p><p>梦里梦见梦里梦不见的也是你</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果冬天里你的手是冰冷的</span></span><br><span class="line"><span class="keyword">if</span>(you.hand==cold&amp;amp;&amp;amp;weather;=winter)</span><br><span class="line"><span class="comment">//将我手上的温度全部给予你</span></span><br><span class="line">  giveyoulove(myhand.temp,yourhand.temp);</span><br><span class="line"><span class="comment">//换取你幸福的脸庞</span></span><br><span class="line"><span class="keyword">return</span> you.happyface;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
